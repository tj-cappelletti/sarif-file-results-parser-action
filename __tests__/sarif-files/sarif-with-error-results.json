{
  "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "CodeQL",
          "organization": "GitHub",
          "semanticVersion": "2.8.1",
          "rules": []
        },
        "extensions": [
          {
            "name": "codeql/javascript-all",
            "semanticVersion": "0.0.10+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/javascript-all/0.0.10/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/javascript-all/0.0.10/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/cpp-queries",
            "semanticVersion": "0.0.9+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/cpp-queries/0.0.9/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/cpp-queries/0.0.9/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/python-all",
            "semanticVersion": "0.0.9+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/python-all/0.0.9/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/python-all/0.0.9/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/ruby-examples",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/ruby-examples/0.0.0/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/ruby-examples/0.0.0/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/csharp-examples",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/csharp-examples/0.0.0/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/csharp-examples/0.0.0/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/java-all",
            "semanticVersion": "0.0.9+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/java-all/0.0.9/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/java-all/0.0.9/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/java-examples",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/java-examples/0.0.0/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/java-examples/0.0.0/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/go-examples",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/go-examples/0.0.0/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/go-examples/0.0.0/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/suite-helpers",
            "semanticVersion": "0.0.3+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/suite-helpers/0.0.3/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/suite-helpers/0.0.3/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/python-examples",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/python-examples/0.0.0/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/python-examples/0.0.0/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/go-all",
            "semanticVersion": "0.0.8+6403a23af36f3dd0a16329c9343319249673e8ac",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/go-all/0.0.8/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/go-all/0.0.8/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/csharp-queries",
            "semanticVersion": "0.0.9+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "notifications": [
              {
                "id": "cs/diagnostics/extraction-errors",
                "name": "cs/diagnostics/extraction-errors",
                "shortDescription": {
                  "text": "Extraction errors"
                },
                "fullDescription": {
                  "text": "List all errors reported by the extractor or the compiler. Extractor errors are limited to those files where there are no compilation errors."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "description": "List all errors reported by the extractor or the compiler. Extractor errors are\n              limited to those files where there are no compilation errors.",
                  "id": "cs/diagnostics/extraction-errors",
                  "kind": "diagnostic",
                  "name": "Extraction errors"
                }
              },
              {
                "id": "cs/diagnostics/successfully-extracted-files",
                "name": "cs/diagnostics/successfully-extracted-files",
                "shortDescription": {
                  "text": "Successfully extracted files"
                },
                "fullDescription": {
                  "text": "A list of all files in the source code directory that were extracted without encountering an extraction or compiler error in the file."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "description": "A list of all files in the source code directory that were extracted\n              without encountering an extraction or compiler error in the file.",
                  "id": "cs/diagnostics/successfully-extracted-files",
                  "kind": "diagnostic",
                  "name": "Successfully extracted files"
                }
              }
            ],
            "rules": [
              {
                "id": "cs/web/debug-binary",
                "name": "cs/web/debug-binary",
                "shortDescription": {
                  "text": "Creating an ASP.NET debug binary may reveal sensitive information"
                },
                "fullDescription": {
                  "text": "ASP.NET projects should not produce debug binaries when deploying to production as debug builds provide additional information useful to a malicious attacker."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Creating an ASP.NET debug binary may reveal sensitive information\nASP.NET applications that deploy a 'debug' build to production can reveal debugging information to end users. This debugging information can aid a malicious user in attacking the system. The use of the debugging flag may also impair performance, increasing execution time and memory usage.\n\n\n## Recommendation\nRemove the 'debug' flag from the `Web.config` file if this configuration is likely to be used in production.\n\n\n## Example\nThe following example shows the 'debug' flag set to true in a `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <compilation\n      defaultLanguage=\"c#\"\n      debug=\"true\"\n    />\n   ...\n  </system.web>\n</configuration>\n```\nThis will produce a 'debug' build that may be exploited by an end user.\n\nTo fix this problem, the 'debug' flag should be set to `false`, or removed completely:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <compilation\n      defaultLanguage=\"c#\"\n    />\n   ...\n  </system.web>\n</configuration>\n```\n\n## References\n* MSDN: [Why debug=false in ASP.NET applications in production environment](https://web.archive.org/web/20190919105353/https://blogs.msdn.microsoft.com/prashant_upadhyay/2011/07/14/why-debugfalse-in-asp-net-applications-in-production-environment/).\n* MSDN: [How to: Enable Debugging for ASP.NET Applications](https://msdn.microsoft.com/en-us/library/e8z01xdh.aspx).\n* Common Weakness Enumeration: [CWE-11](https://cwe.mitre.org/data/definitions/11.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n",
                  "markdown": "# Creating an ASP.NET debug binary may reveal sensitive information\nASP.NET applications that deploy a 'debug' build to production can reveal debugging information to end users. This debugging information can aid a malicious user in attacking the system. The use of the debugging flag may also impair performance, increasing execution time and memory usage.\n\n\n## Recommendation\nRemove the 'debug' flag from the `Web.config` file if this configuration is likely to be used in production.\n\n\n## Example\nThe following example shows the 'debug' flag set to true in a `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <compilation\n      defaultLanguage=\"c#\"\n      debug=\"true\"\n    />\n   ...\n  </system.web>\n</configuration>\n```\nThis will produce a 'debug' build that may be exploited by an end user.\n\nTo fix this problem, the 'debug' flag should be set to `false`, or removed completely:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <compilation\n      defaultLanguage=\"c#\"\n    />\n   ...\n  </system.web>\n</configuration>\n```\n\n## References\n* MSDN: [Why debug=false in ASP.NET applications in production environment](https://web.archive.org/web/20190919105353/https://blogs.msdn.microsoft.com/prashant_upadhyay/2011/07/14/why-debugfalse-in-asp-net-applications-in-production-environment/).\n* MSDN: [How to: Enable Debugging for ASP.NET Applications](https://msdn.microsoft.com/en-us/library/e8z01xdh.aspx).\n* Common Weakness Enumeration: [CWE-11](https://cwe.mitre.org/data/definitions/11.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "maintainability",
                    "frameworks/asp.net",
                    "external/cwe/cwe-11",
                    "external/cwe/cwe-532"
                  ],
                  "description": "ASP.NET projects should not produce debug binaries when deploying to production as\n              debug builds provide additional information useful to a malicious attacker.",
                  "id": "cs/web/debug-binary",
                  "kind": "problem",
                  "name": "Creating an ASP.NET debug binary may reveal sensitive information",
                  "precision": "very-high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/path-injection",
                "name": "cs/path-injection",
                "shortDescription": {
                  "text": "Uncontrolled data used in path expression"
                },
                "fullDescription": {
                  "text": "Accessing paths influenced by users can allow an attacker to access unexpected resources."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may contain unexpected special characters, such as \"..\". Such a path may potentially point to any directory on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path. Ideally, follow these rules:\n\n* Do not allow more than a single \".\" character.\n* Do not allow directory separators such as \"/\" or \"\\\\\" (depending on the file system).\n* Do not rely on simply replacing problematic sequences such as \"../\". For example, after applying this filter to \".../...//\" the resulting string would still be \"../\".\n* Use a whitelist of known good patterns.\n* Sanitize potentially tainted paths using `HttpRequest.MapPath`.\n\n## Example\nIn the first example, a file name is read from a `HttpRequest` and then used to access a file. However, a malicious user could enter a file name which is an absolute path - for example, \"/etc/passwd\". In the second example, it appears that the user is restricted to opening a file within the \"user\" home directory. However, a malicious user could enter a filename which contains special characters. For example, the string \"../../etc/passwd\" will result in the code reading the file located at \"/home/\\[user\\]/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to all the system's passwords.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Web;\n\npublic class TaintedPathHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        String path = ctx.Request.QueryString[\"path\"];\n        // BAD: This could read any file on the filesystem.\n        ctx.Response.Write(File.ReadAllText(path));\n\n        // BAD: This could still read any file on the filesystem.\n        ctx.Response.Write(File.ReadAllText(\"/home/user/\" + path));\n\n        // GOOD: MapPath ensures the path is safe to read from.\n        string safePath = ctx.Request.MapPath(path, ctx.Request.ApplicationPath, false);\n        ctx.Response.Write(File.ReadAllText(safePath));\n    }\n}\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
                  "markdown": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may contain unexpected special characters, such as \"..\". Such a path may potentially point to any directory on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path. Ideally, follow these rules:\n\n* Do not allow more than a single \".\" character.\n* Do not allow directory separators such as \"/\" or \"\\\\\" (depending on the file system).\n* Do not rely on simply replacing problematic sequences such as \"../\". For example, after applying this filter to \".../...//\" the resulting string would still be \"../\".\n* Use a whitelist of known good patterns.\n* Sanitize potentially tainted paths using `HttpRequest.MapPath`.\n\n## Example\nIn the first example, a file name is read from a `HttpRequest` and then used to access a file. However, a malicious user could enter a file name which is an absolute path - for example, \"/etc/passwd\". In the second example, it appears that the user is restricted to opening a file within the \"user\" home directory. However, a malicious user could enter a filename which contains special characters. For example, the string \"../../etc/passwd\" will result in the code reading the file located at \"/home/\\[user\\]/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to all the system's passwords.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Web;\n\npublic class TaintedPathHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        String path = ctx.Request.QueryString[\"path\"];\n        // BAD: This could read any file on the filesystem.\n        ctx.Response.Write(File.ReadAllText(path));\n\n        // BAD: This could still read any file on the filesystem.\n        ctx.Response.Write(File.ReadAllText(\"/home/user/\" + path));\n\n        // GOOD: MapPath ensures the path is safe to read from.\n        string safePath = ctx.Request.MapPath(path, ctx.Request.ApplicationPath, false);\n        ctx.Response.Write(File.ReadAllText(safePath));\n    }\n}\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-022",
                    "external/cwe/cwe-023",
                    "external/cwe/cwe-036",
                    "external/cwe/cwe-073",
                    "external/cwe/cwe-099"
                  ],
                  "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
                  "id": "cs/path-injection",
                  "kind": "path-problem",
                  "name": "Uncontrolled data used in path expression",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/zipslip",
                "name": "cs/zipslip",
                "shortDescription": {
                  "text": "Arbitrary file write during zip extraction (\"Zip Slip\")"
                },
                "fullDescription": {
                  "text": "Extracting files from a malicious zip archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Arbitrary file write during zip extraction (\"Zip Slip\")\nExtracting files from a malicious zip archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten, due to the possible presence of directory traversal elements (`..`) in archive paths.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to determine an output file to write the contents of the archive item to, then the file may be written to an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a zip file contains a file entry `..\\sneaky-file`, and the zip file is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a zip archive entry is to:\n\n1. Use `Path.Combine(destinationDirectory, archiveEntry.FullName)` to determine the raw output path.\n1. Use `Path.GetFullPath(..)` on the raw output path to resolve any directory traversal elements.\n1. Use `Path.GetFullPath(destinationDirectory + Path.DirectorySeparatorChar)` to determine the fully resolved path of the destination directory.\n1. Validate that the resolved output path `StartsWith` the resolved destination directory, aborting if this is not true.\nAnother alternative is to validate archive entries against a whitelist of expected files.\n\n\n## Example\nIn this example, a file path taken from a zip archive item entry is combined with a destination directory. The result is used as the destination file path without verifying that the result is within the destination directory. If provided with a zip file containing an archive path like `..\\sneaky-file`, then this file would be written outside the destination directory.\n\n\n```csharp\nusing System.IO;\nusing System.IO.Compression;\n\nclass Bad\n{\n    public static void WriteToDirectory(ZipArchiveEntry entry,\n                                        string destDirectory)\n    {\n        string destFileName = Path.Combine(destDirectory, entry.FullName);\n        entry.ExtractToFile(destFileName);\n    }\n}\n\n```\nTo fix this vulnerability, we need to make three changes. Firstly, we need to resolve any directory traversal or other special characters in the path by using `Path.GetFullPath`. Secondly, we need to identify the destination output directory, again using `Path.GetFullPath`, this time on the output directory. Finally, we need to ensure that the resolved output starts with the resolved destination directory, and throw an exception if this is not the case.\n\n\n```csharp\nusing System.IO;\nusing System.IO.Compression;\n\nclass Good\n{\n    public static void WriteToDirectory(ZipArchiveEntry entry,\n                                        string destDirectory)\n    {\n        string destFileName = Path.GetFullPath(Path.Combine(destDirectory, entry.FullName));\n        string fullDestDirPath = Path.GetFullPath(destDirectory + Path.DirectorySeparatorChar);\n        if (!destFileName.StartsWith(fullDestDirPath)) {\n            throw new System.InvalidOperationException(\"Entry is outside the target dir: \" +\n                                                                                 destFileName);\n        }\n        entry.ExtractToFile(destFileName);\n    }\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n",
                  "markdown": "# Arbitrary file write during zip extraction (\"Zip Slip\")\nExtracting files from a malicious zip archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten, due to the possible presence of directory traversal elements (`..`) in archive paths.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to determine an output file to write the contents of the archive item to, then the file may be written to an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a zip file contains a file entry `..\\sneaky-file`, and the zip file is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a zip archive entry is to:\n\n1. Use `Path.Combine(destinationDirectory, archiveEntry.FullName)` to determine the raw output path.\n1. Use `Path.GetFullPath(..)` on the raw output path to resolve any directory traversal elements.\n1. Use `Path.GetFullPath(destinationDirectory + Path.DirectorySeparatorChar)` to determine the fully resolved path of the destination directory.\n1. Validate that the resolved output path `StartsWith` the resolved destination directory, aborting if this is not true.\nAnother alternative is to validate archive entries against a whitelist of expected files.\n\n\n## Example\nIn this example, a file path taken from a zip archive item entry is combined with a destination directory. The result is used as the destination file path without verifying that the result is within the destination directory. If provided with a zip file containing an archive path like `..\\sneaky-file`, then this file would be written outside the destination directory.\n\n\n```csharp\nusing System.IO;\nusing System.IO.Compression;\n\nclass Bad\n{\n    public static void WriteToDirectory(ZipArchiveEntry entry,\n                                        string destDirectory)\n    {\n        string destFileName = Path.Combine(destDirectory, entry.FullName);\n        entry.ExtractToFile(destFileName);\n    }\n}\n\n```\nTo fix this vulnerability, we need to make three changes. Firstly, we need to resolve any directory traversal or other special characters in the path by using `Path.GetFullPath`. Secondly, we need to identify the destination output directory, again using `Path.GetFullPath`, this time on the output directory. Finally, we need to ensure that the resolved output starts with the resolved destination directory, and throw an exception if this is not the case.\n\n\n```csharp\nusing System.IO;\nusing System.IO.Compression;\n\nclass Good\n{\n    public static void WriteToDirectory(ZipArchiveEntry entry,\n                                        string destDirectory)\n    {\n        string destFileName = Path.GetFullPath(Path.Combine(destDirectory, entry.FullName));\n        string fullDestDirPath = Path.GetFullPath(destDirectory + Path.DirectorySeparatorChar);\n        if (!destFileName.StartsWith(fullDestDirPath)) {\n            throw new System.InvalidOperationException(\"Entry is outside the target dir: \" +\n                                                                                 destFileName);\n        }\n        entry.ExtractToFile(destFileName);\n    }\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-022"
                  ],
                  "description": "Extracting files from a malicious zip archive without validating that the\n              destination file path is within the destination directory can cause files outside\n              the destination directory to be overwritten.",
                  "id": "cs/zipslip",
                  "kind": "path-problem",
                  "name": "Arbitrary file write during zip extraction (\"Zip Slip\")",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/command-line-injection",
                "name": "cs/command-line-injection",
                "shortDescription": {
                  "text": "Uncontrolled command line"
                },
                "fullDescription": {
                  "text": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Uncontrolled command line\nCode that passes user input directly to `System.Diagnostic.Process.Start`, or some other library routine that executes a command, allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to `System.Diagnostic.Process.Start` without examining it first.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Diagnostics;\n\npublic class CommandInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string param = ctx.Request.QueryString[\"param\"];\n        Process.Start(\"process.exe\", \"/c \" + param);\n    }\n}\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n",
                  "markdown": "# Uncontrolled command line\nCode that passes user input directly to `System.Diagnostic.Process.Start`, or some other library routine that executes a command, allows the user to execute malicious code.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run or library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.\n\nIf the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.\n\n\n## Example\nThe following example shows code that takes a shell script that can be changed maliciously by a user, and passes it straight to `System.Diagnostic.Process.Start` without examining it first.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Diagnostics;\n\npublic class CommandInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string param = ctx.Request.QueryString[\"param\"];\n        Process.Start(\"process.exe\", \"/c \" + param);\n    }\n}\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"
                },
                "properties": {
                  "tags": [
                    "correctness",
                    "security",
                    "external/cwe/cwe-078",
                    "external/cwe/cwe-088"
                  ],
                  "description": "Using externally controlled strings in a command line may allow a malicious\n              user to change the meaning of the command.",
                  "id": "cs/command-line-injection",
                  "kind": "path-problem",
                  "name": "Uncontrolled command line",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/web/xss",
                "name": "cs/web/xss",
                "shortDescription": {
                  "text": "Cross-site scripting"
                },
                "fullDescription": {
                  "text": "Writing user input directly to a web page allows for a cross-site scripting vulnerability."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to a webpage, without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows the page parameter being written directly to the server error page, leaving the website vulnerable to cross-site scripting.\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class XSSHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        ctx.Response.Write(\n            \"The page \\\"\" + ctx.Request.QueryString[\"page\"] + \"\\\" was not found.\");\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
                  "markdown": "# Cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to a webpage, without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows the page parameter being written directly to the server error page, leaving the website vulnerable to cross-site scripting.\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class XSSHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        ctx.Response.Write(\n            \"The page \\\"\" + ctx.Request.QueryString[\"page\"] + \"\\\" was not found.\");\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-079",
                    "external/cwe/cwe-116"
                  ],
                  "description": "Writing user input directly to a web page\n              allows for a cross-site scripting vulnerability.",
                  "id": "cs/web/xss",
                  "kind": "path-problem",
                  "name": "Cross-site scripting",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "6.1"
                }
              },
              {
                "id": "cs/sql-injection",
                "name": "cs/sql-injection",
                "shortDescription": {
                  "text": "SQL query built from user-controlled sources"
                },
                "fullDescription": {
                  "text": "Building a SQL query from user-controlled sources is vulnerable to insertion of malicious SQL code by the user."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# SQL query built from user-controlled sources\nIf a SQL query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries.\n\n\n## Recommendation\nUsually, it is better to use a prepared statement than to build a complete query with string concatenation. A prepared statement can include a parameter, written as either a question mark (`?`) or with an explicit name (`@parameter`), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each parameter in the query.\n\nIt is good practice to use prepared statements for supplying parameters to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in three different ways.\n\nThe first way involves building a query, `query1`, by concatenating a user-supplied text box value with some string literals. The text box value can include special characters, so this code allows for SQL injection attacks.\n\nThe second way uses a stored procedure, `ItemsStoredProcedure`, with a single parameter (`@category`). The parameter is then given a value by calling `Parameters.Add`. This version is immune to injection attacks, because any special characters are not given any special treatment.\n\nThe third way builds a query, `query2`, with a single string literal that includes a parameter (`@category`). The parameter is then given a value by calling `Parameters.Add`. This version is immune to injection attacks, because any special characters are not given any special treatment.\n\n\n```csharp\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Web.UI.WebControls;\n\nclass SqlInjection\n{\n    TextBox categoryTextBox;\n    string connectionString;\n\n    public DataSet GetDataSetByCategory()\n    {\n        // BAD: the category might have SQL special characters in it\n        using (var connection = new SqlConnection(connectionString))\n        {\n            var query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n              + categoryTextBox.Text + \"' ORDER BY PRICE\";\n            var adapter = new SqlDataAdapter(query1, connection);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n\n        // GOOD: use parameters with stored procedures\n        using (var connection = new SqlConnection(connectionString))\n        {\n            var adapter = new SqlDataAdapter(\"ItemsStoredProcedure\", connection);\n            adapter.SelectCommand.CommandType = CommandType.StoredProcedure;\n            var parameter = new SqlParameter(\"category\", categoryTextBox.Text);\n            adapter.SelectCommand.Parameters.Add(parameter);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n\n        // GOOD: use parameters with dynamic SQL\n        using (var connection = new SqlConnection(connectionString))\n        {\n            var query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=\"\n              + \"@category ORDER BY PRICE\";\n            var adapter = new SqlDataAdapter(query2, connection);\n            var parameter = new SqlParameter(\"category\", categoryTextBox.Text);\n            adapter.SelectCommand.Parameters.Add(parameter);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n    }\n}\n\n```\n\n## References\n* MSDN: [How To: Protect From SQL Injection in ASP.NET](https://msdn.microsoft.com/en-us/library/ff648339.aspx).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n",
                  "markdown": "# SQL query built from user-controlled sources\nIf a SQL query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries.\n\n\n## Recommendation\nUsually, it is better to use a prepared statement than to build a complete query with string concatenation. A prepared statement can include a parameter, written as either a question mark (`?`) or with an explicit name (`@parameter`), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each parameter in the query.\n\nIt is good practice to use prepared statements for supplying parameters to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in three different ways.\n\nThe first way involves building a query, `query1`, by concatenating a user-supplied text box value with some string literals. The text box value can include special characters, so this code allows for SQL injection attacks.\n\nThe second way uses a stored procedure, `ItemsStoredProcedure`, with a single parameter (`@category`). The parameter is then given a value by calling `Parameters.Add`. This version is immune to injection attacks, because any special characters are not given any special treatment.\n\nThe third way builds a query, `query2`, with a single string literal that includes a parameter (`@category`). The parameter is then given a value by calling `Parameters.Add`. This version is immune to injection attacks, because any special characters are not given any special treatment.\n\n\n```csharp\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Web.UI.WebControls;\n\nclass SqlInjection\n{\n    TextBox categoryTextBox;\n    string connectionString;\n\n    public DataSet GetDataSetByCategory()\n    {\n        // BAD: the category might have SQL special characters in it\n        using (var connection = new SqlConnection(connectionString))\n        {\n            var query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n              + categoryTextBox.Text + \"' ORDER BY PRICE\";\n            var adapter = new SqlDataAdapter(query1, connection);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n\n        // GOOD: use parameters with stored procedures\n        using (var connection = new SqlConnection(connectionString))\n        {\n            var adapter = new SqlDataAdapter(\"ItemsStoredProcedure\", connection);\n            adapter.SelectCommand.CommandType = CommandType.StoredProcedure;\n            var parameter = new SqlParameter(\"category\", categoryTextBox.Text);\n            adapter.SelectCommand.Parameters.Add(parameter);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n\n        // GOOD: use parameters with dynamic SQL\n        using (var connection = new SqlConnection(connectionString))\n        {\n            var query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=\"\n              + \"@category ORDER BY PRICE\";\n            var adapter = new SqlDataAdapter(query2, connection);\n            var parameter = new SqlParameter(\"category\", categoryTextBox.Text);\n            adapter.SelectCommand.Parameters.Add(parameter);\n            var result = new DataSet();\n            adapter.Fill(result);\n            return result;\n        }\n    }\n}\n\n```\n\n## References\n* MSDN: [How To: Protect From SQL Injection in ASP.NET](https://msdn.microsoft.com/en-us/library/ff648339.aspx).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-089"
                  ],
                  "description": "Building a SQL query from user-controlled sources is vulnerable to insertion of\n              malicious SQL code by the user.",
                  "id": "cs/sql-injection",
                  "kind": "path-problem",
                  "name": "SQL query built from user-controlled sources",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "8.8"
                }
              },
              {
                "id": "cs/ldap-injection",
                "name": "cs/ldap-injection",
                "shortDescription": {
                  "text": "LDAP query built from user-controlled sources"
                },
                "fullDescription": {
                  "text": "Building an LDAP query from user-controlled sources is vulnerable to insertion of malicious LDAP code by the user."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# LDAP query built from user-controlled sources\nIf an LDAP query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious LDAP queries.\n\n\n## Recommendation\nIf user input must be included in an LDAP query, it should be escaped to avoid a malicious user providing special characters that change the meaning of the query. If possible, use an existing library, such as the AntiXSS library.\n\n\n## Example\nIn the following examples, the code accepts an \"organization name\" and a \"username\" from the user, which it uses to query LDAP to access a \"type\" property.\n\nThe first example concatenates the unvalidated and unencoded user input directly into both the DN (Distinguished Name) and the search filter used for the LDAP query. A malicious user could provide special characters to change the meaning of these queries, and search for a completely different set of values.\n\nThe second example uses the Microsoft AntiXSS library to encode the user values before they are included in the DN and search filters. This ensures the meaning of the query cannot be changed by a malicious user.\n\n\n```csharp\nusing Microsoft.Security.Application.Encoder\nusing System;\nusing System.DirectoryServices;\nusing System.Web;\n\npublic class LDAPInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userName = ctx.Request.QueryString[\"username\"];\n        string organizationName = ctx.Request.QueryString[\"organization_name\"];\n        // BAD: User input used in DN (Distinguished Name) without encoding\n        string ldapQuery = \"LDAP://myserver/OU=People,O=\" + organizationName;\n        using (DirectoryEntry root = new DirectoryEntry(ldapQuery))\n        {\n            // BAD: User input used in search filter without encoding\n            DirectorySearcher ds = new DirectorySearcher(root, \"username=\" + userName);\n\n            SearchResult result = ds.FindOne();\n            if (result != null)\n            {\n                using (DirectoryEntry user = result.getDirectoryEntry())\n                {\n                    ctx.Response.Write(user.Properties[\"type\"].Value)\n                }\n            }\n        }\n\n        // GOOD: Organization name is encoded before being used in DN\n        string safeOrganizationName = Encoder.LdapDistinguishedNameEncode(organizationName);\n        string safeLDAPQuery = \"LDAP://myserver/OU=People,O=\" + safeOrganizationName;\n        using (DirectoryEntry root = new DirectoryEntry(safeLDAPQuery))\n        {\n            // GOOD: User input is encoded before being used in search filter\n            string safeUserName = Encoder.LdapFilterEncode(userName);\n            DirectorySearcher ds = new DirectorySearcher(root, \"username=\" + safeUserName);\n\n            SearchResult result = ds.FindOne();\n            if (result != null)\n            {\n                using (DirectoryEntry user = result.getDirectoryEntry())\n                {\n                    ctx.Response.Write(user.Properties[\"type\"].Value)\n                }\n            }\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).\n* OWASP: [Preventing LDAP Injection in Java](https://www.owasp.org/index.php/Preventing_LDAP_Injection_in_Java).\n* AntiXSS doc: [LdapFilterEncode](http://www.nudoq.org/#!/Packages/AntiXSS/AntiXssLibrary/Encoder/M/LdapFilterEncode).\n* AntiXSS doc: [LdapDistinguishedNameEncode](http://www.nudoq.org/#!/Packages/AntiXSS/AntiXssLibrary/Encoder/M/LdapDistinguishedNameEncode).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n",
                  "markdown": "# LDAP query built from user-controlled sources\nIf an LDAP query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious LDAP queries.\n\n\n## Recommendation\nIf user input must be included in an LDAP query, it should be escaped to avoid a malicious user providing special characters that change the meaning of the query. If possible, use an existing library, such as the AntiXSS library.\n\n\n## Example\nIn the following examples, the code accepts an \"organization name\" and a \"username\" from the user, which it uses to query LDAP to access a \"type\" property.\n\nThe first example concatenates the unvalidated and unencoded user input directly into both the DN (Distinguished Name) and the search filter used for the LDAP query. A malicious user could provide special characters to change the meaning of these queries, and search for a completely different set of values.\n\nThe second example uses the Microsoft AntiXSS library to encode the user values before they are included in the DN and search filters. This ensures the meaning of the query cannot be changed by a malicious user.\n\n\n```csharp\nusing Microsoft.Security.Application.Encoder\nusing System;\nusing System.DirectoryServices;\nusing System.Web;\n\npublic class LDAPInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userName = ctx.Request.QueryString[\"username\"];\n        string organizationName = ctx.Request.QueryString[\"organization_name\"];\n        // BAD: User input used in DN (Distinguished Name) without encoding\n        string ldapQuery = \"LDAP://myserver/OU=People,O=\" + organizationName;\n        using (DirectoryEntry root = new DirectoryEntry(ldapQuery))\n        {\n            // BAD: User input used in search filter without encoding\n            DirectorySearcher ds = new DirectorySearcher(root, \"username=\" + userName);\n\n            SearchResult result = ds.FindOne();\n            if (result != null)\n            {\n                using (DirectoryEntry user = result.getDirectoryEntry())\n                {\n                    ctx.Response.Write(user.Properties[\"type\"].Value)\n                }\n            }\n        }\n\n        // GOOD: Organization name is encoded before being used in DN\n        string safeOrganizationName = Encoder.LdapDistinguishedNameEncode(organizationName);\n        string safeLDAPQuery = \"LDAP://myserver/OU=People,O=\" + safeOrganizationName;\n        using (DirectoryEntry root = new DirectoryEntry(safeLDAPQuery))\n        {\n            // GOOD: User input is encoded before being used in search filter\n            string safeUserName = Encoder.LdapFilterEncode(userName);\n            DirectorySearcher ds = new DirectorySearcher(root, \"username=\" + safeUserName);\n\n            SearchResult result = ds.FindOne();\n            if (result != null)\n            {\n                using (DirectoryEntry user = result.getDirectoryEntry())\n                {\n                    ctx.Response.Write(user.Properties[\"type\"].Value)\n                }\n            }\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).\n* OWASP: [Preventing LDAP Injection in Java](https://www.owasp.org/index.php/Preventing_LDAP_Injection_in_Java).\n* AntiXSS doc: [LdapFilterEncode](http://www.nudoq.org/#!/Packages/AntiXSS/AntiXssLibrary/Encoder/M/LdapFilterEncode).\n* AntiXSS doc: [LdapDistinguishedNameEncode](http://www.nudoq.org/#!/Packages/AntiXSS/AntiXssLibrary/Encoder/M/LdapDistinguishedNameEncode).\n* Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-090"
                  ],
                  "description": "Building an LDAP query from user-controlled sources is vulnerable to insertion of\n              malicious LDAP code by the user.",
                  "id": "cs/ldap-injection",
                  "kind": "path-problem",
                  "name": "LDAP query built from user-controlled sources",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/xml-injection",
                "name": "cs/xml-injection",
                "shortDescription": {
                  "text": "XML injection"
                },
                "fullDescription": {
                  "text": "Building an XML document from user-controlled sources is vulnerable to insertion of malicious code by the user."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# XML injection\nThe APIs provided by the .NET libraries for XML manipulation allow the insertion of \"raw\" text at a specified point in an XML document. If user input is passed to this API, it could allow a malicious user to add extra content that could corrupt or supersede existing content, or enable unintended additional functionality.\n\n\n## Recommendation\nAvoid using the `WriteRaw` method on `System.Xml.XmlWriter` with user input. If possible, use the high-level APIs to write new XML elements to a document, as these automatically escape user content. If that is not possible, then user input should be escaped before being included in a string that will be used with the `WriteRaw` API.\n\n\n## Example\nIn this example, user input is provided describing the name of an employee to add to an XML document representing a set of names. The `WriteRaw` API is used to write the new employee record to the XML file.\n\n\n```csharp\nusing System;\nusing System.Security;\nusing System.Web;\nusing System.Xml;\n\npublic class XMLInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string employeeName = ctx.Request.QueryString[\"employeeName\"];\n\n    using (XmlWriter writer = XmlWriter.Create(\"employees.xml\"))\n    {\n        writer.WriteStartDocument();\n\n        // BAD: Insert user input directly into XML\n        writer.WriteRaw(\"<employee><name>\" + employeeName + \"</name></employee>\");\n\n        writer.WriteEndElement();\n        writer.WriteEndDocument();\n    }\n  }\n}\n```\nHowever, if a malicious user were to provide the content `Bobby Pages</name></employee><employee><name>Hacker1`, they would be able to add an extra entry into the XML file.\n\nThe corrected version demonstrates two ways to avoid this issue. The first is to escape user input before passing it to the `WriteRaw` API, which prevents a malicious user from closing or opening XML tags. The second approach uses the high level XML API to add XML elements, which ensures the content is appropriately escaped.\n\n\n```csharp\nusing System;\nusing System.Security;\nusing System.Web;\nusing System.Xml;\n\npublic class XMLInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string employeeName = ctx.Request.QueryString[\"employeeName\"];\n\n    using (XmlWriter writer = XmlWriter.Create(\"employees.xml\"))\n    {\n        writer.WriteStartDocument();\n\n        // GOOD: Escape user input before inserting into string\n        writer.WriteRaw(\"<employee><name>\" + SecurityElement.Escape(employeeName) + \"</name></employee>\");\n\n        // GOOD: Use standard API, which automatically encodes values\n        writer.WriteStartElement(\"Employee\");\n        writer.WriteElementString(\"Name\", employeeName);\n        writer.WriteEndElement();\n\n        writer.WriteEndElement();\n        writer.WriteEndDocument();\n    }\n  }\n```\n\n## References\n* Web Application Security Consortium: [XML Injection](http://projects.webappsec.org/w/page/13247004/XML%20Injection).\n* Microsoft Docs: [WriteRaw](https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmlwriter.writeraw?view=netframework-4.8).\n* Common Weakness Enumeration: [CWE-91](https://cwe.mitre.org/data/definitions/91.html).\n",
                  "markdown": "# XML injection\nThe APIs provided by the .NET libraries for XML manipulation allow the insertion of \"raw\" text at a specified point in an XML document. If user input is passed to this API, it could allow a malicious user to add extra content that could corrupt or supersede existing content, or enable unintended additional functionality.\n\n\n## Recommendation\nAvoid using the `WriteRaw` method on `System.Xml.XmlWriter` with user input. If possible, use the high-level APIs to write new XML elements to a document, as these automatically escape user content. If that is not possible, then user input should be escaped before being included in a string that will be used with the `WriteRaw` API.\n\n\n## Example\nIn this example, user input is provided describing the name of an employee to add to an XML document representing a set of names. The `WriteRaw` API is used to write the new employee record to the XML file.\n\n\n```csharp\nusing System;\nusing System.Security;\nusing System.Web;\nusing System.Xml;\n\npublic class XMLInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string employeeName = ctx.Request.QueryString[\"employeeName\"];\n\n    using (XmlWriter writer = XmlWriter.Create(\"employees.xml\"))\n    {\n        writer.WriteStartDocument();\n\n        // BAD: Insert user input directly into XML\n        writer.WriteRaw(\"<employee><name>\" + employeeName + \"</name></employee>\");\n\n        writer.WriteEndElement();\n        writer.WriteEndDocument();\n    }\n  }\n}\n```\nHowever, if a malicious user were to provide the content `Bobby Pages</name></employee><employee><name>Hacker1`, they would be able to add an extra entry into the XML file.\n\nThe corrected version demonstrates two ways to avoid this issue. The first is to escape user input before passing it to the `WriteRaw` API, which prevents a malicious user from closing or opening XML tags. The second approach uses the high level XML API to add XML elements, which ensures the content is appropriately escaped.\n\n\n```csharp\nusing System;\nusing System.Security;\nusing System.Web;\nusing System.Xml;\n\npublic class XMLInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string employeeName = ctx.Request.QueryString[\"employeeName\"];\n\n    using (XmlWriter writer = XmlWriter.Create(\"employees.xml\"))\n    {\n        writer.WriteStartDocument();\n\n        // GOOD: Escape user input before inserting into string\n        writer.WriteRaw(\"<employee><name>\" + SecurityElement.Escape(employeeName) + \"</name></employee>\");\n\n        // GOOD: Use standard API, which automatically encodes values\n        writer.WriteStartElement(\"Employee\");\n        writer.WriteElementString(\"Name\", employeeName);\n        writer.WriteEndElement();\n\n        writer.WriteEndElement();\n        writer.WriteEndDocument();\n    }\n  }\n```\n\n## References\n* Web Application Security Consortium: [XML Injection](http://projects.webappsec.org/w/page/13247004/XML%20Injection).\n* Microsoft Docs: [WriteRaw](https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmlwriter.writeraw?view=netframework-4.8).\n* Common Weakness Enumeration: [CWE-91](https://cwe.mitre.org/data/definitions/91.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-091"
                  ],
                  "description": "Building an XML document from user-controlled sources is vulnerable to insertion of\n              malicious code by the user.",
                  "id": "cs/xml-injection",
                  "kind": "problem",
                  "name": "XML injection",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "8.8"
                }
              },
              {
                "id": "cs/code-injection",
                "name": "cs/code-injection",
                "shortDescription": {
                  "text": "Improper control of generation of code"
                },
                "fullDescription": {
                  "text": "Treating externally controlled strings as code can allow an attacker to execute malicious code."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Improper control of generation of code\nIf the application dynamically compiles and runs source code constructed from user input, a malicious user may be able to run arbitrary code.\n\n\n## Recommendation\nIt is good practice not to generate, compile and run source code constructed from untrusted user input. If code must be dynamically generated using user input, the user input should be validated to prevent arbitrary code from appearing in the input. For example, a whitelist may be used to ensure that the input is limited to an acceptable range of values.\n\n\n## Example\nIn the following example, the HttpHandler accepts remote user input which is C\\# source code for calculating tax. It compiles and runs this code, returning the output. However, the user provided source code is entirely unvalidated, and therefore allows arbitrary code execution.\n\nIf possible, the dynamic compilation should be removed all together, and replaced with a fixed set of tax calculation algorithms. If this is not sufficiently powerful, an interpreter could be provided for a safe, restricted language.\n\n\n```csharp\nusing Microsoft.CSharp;\nusing System;\nusing System.CodeDom.Compiler;\nusing System.Reflection;\nusing System.Web;\n\npublic class CodeInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // Code for calculating tax is provided as unvalidated user input\n        string taxFormula = ctx.Request.QueryString[\"tax_formula\"];\n        // Used to create C#\n        StringBuilder sourceCode = new StringBuilder(\"\");\n        sourceCode.Append(\"public class TaxCalc {\\n\");\n        sourceCode.Append(\"\\tpublic int CalculateTax(int value){\\n\");\n        sourceCode.Append(\"\\t\\treturn \" + taxFormula + \"; \\n\");\n        sourceCode.Append(\"\\t}\\n\");\n        sourceCode.Append(\"}\\n\");\n\n        // BAD: This compiles the sourceCode, containing unvalidated user input\n        CSharpCodeProvider c = new CSharpCodeProvider();\n        ICodeCompiler icc = c.CreateCompiler();\n        CompilerParameters cp = new CompilerParameters();\n        CompilerResults cr = icc.CompileAssemblyFromSource(cp, sourceCode.ToString());\n\n        // Compiled input is loaded, and an instance of the class is constructed\n        System.Reflection.Assembly a = cr.CompiledAssembly;\n        object taxCalc = a.CreateInstance(\"TaxCalc\");\n\n        // Unsafe code is executed\n        Type taxCalcType = o.GetType();\n        MethodInfo mi = type.GetMethod(\"CalculateTax\");\n        int value = int.Parse(ctx.Request.QueryString[\"value\"]);\n        int s = (int)mi.Invoke(o, new object[] { value });\n\n        // Result is returned to the user\n        ctx.Response.Write(\"Tax value is: \" + s);\n    }\n}\n\n```\n\n## References\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-96](https://cwe.mitre.org/data/definitions/96.html).\n",
                  "markdown": "# Improper control of generation of code\nIf the application dynamically compiles and runs source code constructed from user input, a malicious user may be able to run arbitrary code.\n\n\n## Recommendation\nIt is good practice not to generate, compile and run source code constructed from untrusted user input. If code must be dynamically generated using user input, the user input should be validated to prevent arbitrary code from appearing in the input. For example, a whitelist may be used to ensure that the input is limited to an acceptable range of values.\n\n\n## Example\nIn the following example, the HttpHandler accepts remote user input which is C\\# source code for calculating tax. It compiles and runs this code, returning the output. However, the user provided source code is entirely unvalidated, and therefore allows arbitrary code execution.\n\nIf possible, the dynamic compilation should be removed all together, and replaced with a fixed set of tax calculation algorithms. If this is not sufficiently powerful, an interpreter could be provided for a safe, restricted language.\n\n\n```csharp\nusing Microsoft.CSharp;\nusing System;\nusing System.CodeDom.Compiler;\nusing System.Reflection;\nusing System.Web;\n\npublic class CodeInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // Code for calculating tax is provided as unvalidated user input\n        string taxFormula = ctx.Request.QueryString[\"tax_formula\"];\n        // Used to create C#\n        StringBuilder sourceCode = new StringBuilder(\"\");\n        sourceCode.Append(\"public class TaxCalc {\\n\");\n        sourceCode.Append(\"\\tpublic int CalculateTax(int value){\\n\");\n        sourceCode.Append(\"\\t\\treturn \" + taxFormula + \"; \\n\");\n        sourceCode.Append(\"\\t}\\n\");\n        sourceCode.Append(\"}\\n\");\n\n        // BAD: This compiles the sourceCode, containing unvalidated user input\n        CSharpCodeProvider c = new CSharpCodeProvider();\n        ICodeCompiler icc = c.CreateCompiler();\n        CompilerParameters cp = new CompilerParameters();\n        CompilerResults cr = icc.CompileAssemblyFromSource(cp, sourceCode.ToString());\n\n        // Compiled input is loaded, and an instance of the class is constructed\n        System.Reflection.Assembly a = cr.CompiledAssembly;\n        object taxCalc = a.CreateInstance(\"TaxCalc\");\n\n        // Unsafe code is executed\n        Type taxCalcType = o.GetType();\n        MethodInfo mi = type.GetMethod(\"CalculateTax\");\n        int value = int.Parse(ctx.Request.QueryString[\"value\"]);\n        int s = (int)mi.Invoke(o, new object[] { value });\n\n        // Result is returned to the user\n        ctx.Response.Write(\"Tax value is: \" + s);\n    }\n}\n\n```\n\n## References\n* Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).\n* Common Weakness Enumeration: [CWE-96](https://cwe.mitre.org/data/definitions/96.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-094",
                    "external/cwe/cwe-095",
                    "external/cwe/cwe-096"
                  ],
                  "description": "Treating externally controlled strings as code can allow an attacker to execute\n              malicious code.",
                  "id": "cs/code-injection",
                  "kind": "path-problem",
                  "name": "Improper control of generation of code",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.3"
                }
              },
              {
                "id": "cs/resource-injection",
                "name": "cs/resource-injection",
                "shortDescription": {
                  "text": "Resource injection"
                },
                "fullDescription": {
                  "text": "Building a resource descriptor from untrusted user input is vulnerable to a malicious user providing an unintended resource."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Resource injection\nIf a resource descriptor is built using string concatenation, and the components of the concatenation include user input, a user may be able to hijack the resource which is loaded.\n\n\n## Recommendation\nIf user input must be included in a resource descriptor, it should be escaped to avoid a malicious user providing special characters that change the meaning of the descriptor. If possible, use an existing library to either escape or construct the resource.\n\nFor data connections within sub namespaces of `System.Data`, a connection builder class is provided. For example, a connection string which is to be passed to `System.Data.SqlClient.SqlConnection` can be constructed safely using an instance of `System.Data.SqlClient.SqlConnectionStringBuilder`.\n\n\n## Example\nIn the following examples, the code accepts a user name from the user, which it uses to create a connection string for an SQL database.\n\nThe first example concatenates the unvalidated and unencoded user input directly into the connection string. A malicious user could provide special characters to change the meaning of the connection string, and connect to a completely different server.\n\nThe second example uses the `SqlConnectionStringBuilder` to construct the connection string and therefore prevents a malicious user modifying the meaning of the connection string.\n\n\n```csharp\nusing System.Data.SqlClient;\nusing System.Web;\n\npublic class ResourceInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userName = ctx.Request.QueryString[\"userName\"];\n\n        // BAD: Direct use of user input in a connection string passed to SqlConnection\n        string connectionString = \"server=(local);user id=\" + userName + \";password= pass;\";\n        SqlConnection sqlConnectionBad = new SqlConnection(connectionString);\n\n        // GOOD: Use SqlConnectionStringBuilder to safely include user input in a connection string\n        SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder();\n        builder[\"Data Source\"] = \"(local)\";\n        builder[\"integrated Security\"] = true;\n        builder[\"user id\"] = userName;\n        SqlConnection sqlConnectionGood = new SqlConnection(builder.ConnectionString);\n    }\n}\n\n```\n\n## References\n* OWASP: [Resource Injection](https://www.owasp.org/index.php/Resource_Injection).\n* MSDN: [Building Connection Strings](https://msdn.microsoft.com/en-us/library/ms254947(v=vs.80).aspx).\n* MSDN: [Securing Connection Strings](https://msdn.microsoft.com/en-us/library/89211k9b(VS.80).aspx).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
                  "markdown": "# Resource injection\nIf a resource descriptor is built using string concatenation, and the components of the concatenation include user input, a user may be able to hijack the resource which is loaded.\n\n\n## Recommendation\nIf user input must be included in a resource descriptor, it should be escaped to avoid a malicious user providing special characters that change the meaning of the descriptor. If possible, use an existing library to either escape or construct the resource.\n\nFor data connections within sub namespaces of `System.Data`, a connection builder class is provided. For example, a connection string which is to be passed to `System.Data.SqlClient.SqlConnection` can be constructed safely using an instance of `System.Data.SqlClient.SqlConnectionStringBuilder`.\n\n\n## Example\nIn the following examples, the code accepts a user name from the user, which it uses to create a connection string for an SQL database.\n\nThe first example concatenates the unvalidated and unencoded user input directly into the connection string. A malicious user could provide special characters to change the meaning of the connection string, and connect to a completely different server.\n\nThe second example uses the `SqlConnectionStringBuilder` to construct the connection string and therefore prevents a malicious user modifying the meaning of the connection string.\n\n\n```csharp\nusing System.Data.SqlClient;\nusing System.Web;\n\npublic class ResourceInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userName = ctx.Request.QueryString[\"userName\"];\n\n        // BAD: Direct use of user input in a connection string passed to SqlConnection\n        string connectionString = \"server=(local);user id=\" + userName + \";password= pass;\";\n        SqlConnection sqlConnectionBad = new SqlConnection(connectionString);\n\n        // GOOD: Use SqlConnectionStringBuilder to safely include user input in a connection string\n        SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder();\n        builder[\"Data Source\"] = \"(local)\";\n        builder[\"integrated Security\"] = true;\n        builder[\"user id\"] = userName;\n        SqlConnection sqlConnectionGood = new SqlConnection(builder.ConnectionString);\n    }\n}\n\n```\n\n## References\n* OWASP: [Resource Injection](https://www.owasp.org/index.php/Resource_Injection).\n* MSDN: [Building Connection Strings](https://msdn.microsoft.com/en-us/library/ms254947(v=vs.80).aspx).\n* MSDN: [Securing Connection Strings](https://msdn.microsoft.com/en-us/library/89211k9b(VS.80).aspx).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-099"
                  ],
                  "description": "Building a resource descriptor from untrusted user input is vulnerable to a\n              malicious user providing an unintended resource.",
                  "id": "cs/resource-injection",
                  "kind": "path-problem",
                  "name": "Resource injection",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/assembly-path-injection",
                "name": "cs/assembly-path-injection",
                "shortDescription": {
                  "text": "Assembly path injection"
                },
                "fullDescription": {
                  "text": "Loading a .NET assembly based on a path constructed from user-controlled sources may allow a malicious user to load code which modifies the program in unintended ways."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Assembly path injection\nC\\# supports runtime loading of assemblies by path through the use of the `System.Reflection.Assembly` API. If an external user can influence the path used to load an assembly, then the application can potentially be tricked into loading an assembly which was not intended to be loaded, and executing arbitrary code.\n\n\n## Recommendation\nAvoid loading assemblies based on user provided input. If this is not possible, ensure that the path is validated before being used with `Assembly`. For example, compare the provided input against a whitelist of known safe assemblies, or confirm that the path is restricted to a single directory which only contains safe assemblies.\n\n\n## Example\nIn this example, user input is provided describing the path to an assembly, which is loaded without validation. This is problematic because it allows the user to load any assembly installed on the system, and is particularly problematic if an attacker can upload a custom DLL elsewhere on the system.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Reflection;\n\npublic class AssemblyPathInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string assemblyPath = ctx.Request.QueryString[\"assemblyPath\"];\n\n    // BAD: Load assembly based on user input\n    var badAssembly = Assembly.LoadFile(assemblyPath);\n\n    // Method called on loaded assembly. If the user can control the loaded assembly, then this\n    // could result in a remote code execution vulnerability\n    MethodInfo m = badAssembly.GetType(\"Config\").GetMethod(\"GetCustomPath\");\n    Object customPath = m.Invoke(null, null);\n    // ...\n  }\n}\n```\nIn the corrected version, user input is validated against one of two options, and the assembly is only loaded if the user input matches one of those options.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Reflection;\n\npublic class AssemblyPathInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string configType = ctx.Request.QueryString[\"configType\"];\n\n    if (configType.equals(\"configType1\") || configType.equals(\"configType2\")) {\n      // GOOD: Loaded assembly is one of the two known safe options\n      var safeAssembly = Assembly.LoadFile(@\"C:\\SafeLibraries\\\" + configType + \".dll\");\n\n      // Code execution is limited to one of two known and vetted assemblies\n      MethodInfo m = safeAssembly.GetType(\"Config\").GetMethod(\"GetCustomPath\");\n      Object customPath = m.Invoke(null, null);\n      // ...\n    }\n  }\n}\n```\n\n## References\n* Microsoft: [System.Reflection.Assembly](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly?view=netframework-4.8).\n* Common Weakness Enumeration: [CWE-114](https://cwe.mitre.org/data/definitions/114.html).\n",
                  "markdown": "# Assembly path injection\nC\\# supports runtime loading of assemblies by path through the use of the `System.Reflection.Assembly` API. If an external user can influence the path used to load an assembly, then the application can potentially be tricked into loading an assembly which was not intended to be loaded, and executing arbitrary code.\n\n\n## Recommendation\nAvoid loading assemblies based on user provided input. If this is not possible, ensure that the path is validated before being used with `Assembly`. For example, compare the provided input against a whitelist of known safe assemblies, or confirm that the path is restricted to a single directory which only contains safe assemblies.\n\n\n## Example\nIn this example, user input is provided describing the path to an assembly, which is loaded without validation. This is problematic because it allows the user to load any assembly installed on the system, and is particularly problematic if an attacker can upload a custom DLL elsewhere on the system.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Reflection;\n\npublic class AssemblyPathInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string assemblyPath = ctx.Request.QueryString[\"assemblyPath\"];\n\n    // BAD: Load assembly based on user input\n    var badAssembly = Assembly.LoadFile(assemblyPath);\n\n    // Method called on loaded assembly. If the user can control the loaded assembly, then this\n    // could result in a remote code execution vulnerability\n    MethodInfo m = badAssembly.GetType(\"Config\").GetMethod(\"GetCustomPath\");\n    Object customPath = m.Invoke(null, null);\n    // ...\n  }\n}\n```\nIn the corrected version, user input is validated against one of two options, and the assembly is only loaded if the user input matches one of those options.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Reflection;\n\npublic class AssemblyPathInjectionHandler : IHttpHandler {\n  public void ProcessRequest(HttpContext ctx) {\n    string configType = ctx.Request.QueryString[\"configType\"];\n\n    if (configType.equals(\"configType1\") || configType.equals(\"configType2\")) {\n      // GOOD: Loaded assembly is one of the two known safe options\n      var safeAssembly = Assembly.LoadFile(@\"C:\\SafeLibraries\\\" + configType + \".dll\");\n\n      // Code execution is limited to one of two known and vetted assemblies\n      MethodInfo m = safeAssembly.GetType(\"Config\").GetMethod(\"GetCustomPath\");\n      Object customPath = m.Invoke(null, null);\n      // ...\n    }\n  }\n}\n```\n\n## References\n* Microsoft: [System.Reflection.Assembly](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly?view=netframework-4.8).\n* Common Weakness Enumeration: [CWE-114](https://cwe.mitre.org/data/definitions/114.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-114"
                  ],
                  "description": "Loading a .NET assembly based on a path constructed from user-controlled sources\n              may allow a malicious user to load code which modifies the program in unintended\n              ways.",
                  "id": "cs/assembly-path-injection",
                  "kind": "problem",
                  "name": "Assembly path injection",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "8.2"
                }
              },
              {
                "id": "cs/log-forging",
                "name": "cs/log-forging",
                "shortDescription": {
                  "text": "Log entries created from user input"
                },
                "fullDescription": {
                  "text": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Log entries created from user input\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be include to spoof log entries.\n\n\n## Recommendation\nUser input should be suitably encoded before it is logged.\n\nIf the log entries are plain text then line breaks should be removed from user input, using `String.Replace` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.\n\nFor log entries that will be displayed in HTML, user input should be HTML encoded using `HttpServerUtility.HtmlEncode` or similar before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the following example, a user name, provided by the user, is logged using a logging framework. In the first case, it is logged without any sanitization. In the second case, `String.Replace` is used to ensure no line endings are present in the user input.\n\n\n```csharp\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO;\nusing System.Web;\n\npublic class LogForgingHandler : IHttpHandler\n{\n    private ILogger logger;\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        String username = ctx.Request.QueryString[\"username\"];\n        // BAD: User input logged as-is\n        logger.Warn(username + \" log in requested.\");\n        // GOOD: User input logged with new-lines removed\n        logger.Warn(username.Replace(Environment.NewLine, \"\") + \" log in requested\");\n    }\n}\n\n```\n\n## References\n* OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n",
                  "markdown": "# Log entries created from user input\nIf unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.\n\nForgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be include to spoof log entries.\n\n\n## Recommendation\nUser input should be suitably encoded before it is logged.\n\nIf the log entries are plain text then line breaks should be removed from user input, using `String.Replace` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.\n\nFor log entries that will be displayed in HTML, user input should be HTML encoded using `HttpServerUtility.HtmlEncode` or similar before being logged, to prevent forgery and other forms of HTML injection.\n\n\n## Example\nIn the following example, a user name, provided by the user, is logged using a logging framework. In the first case, it is logged without any sanitization. In the second case, `String.Replace` is used to ensure no line endings are present in the user input.\n\n\n```csharp\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO;\nusing System.Web;\n\npublic class LogForgingHandler : IHttpHandler\n{\n    private ILogger logger;\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        String username = ctx.Request.QueryString[\"username\"];\n        // BAD: User input logged as-is\n        logger.Warn(username + \" log in requested.\");\n        // GOOD: User input logged with new-lines removed\n        logger.Warn(username.Replace(Environment.NewLine, \"\") + \" log in requested\");\n    }\n}\n\n```\n\n## References\n* OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).\n* Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-117"
                  ],
                  "description": "Building log entries from user-controlled sources is vulnerable to\n              insertion of forged log entries by a malicious user.",
                  "id": "cs/log-forging",
                  "kind": "path-problem",
                  "name": "Log entries created from user input",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.8"
                }
              },
              {
                "id": "cs/unvalidated-local-pointer-arithmetic",
                "name": "cs/unvalidated-local-pointer-arithmetic",
                "shortDescription": {
                  "text": "Unvalidated local pointer arithmetic"
                },
                "fullDescription": {
                  "text": "Using the result of a virtual method call in pointer arithmetic without validation is dangerous because the method may be overridden by a subtype to return any value."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Unvalidated local pointer arithmetic\nIt is dangerous to use the result of a virtual method call in pointer arithmetic without validation if external users can provide their own implementation of the virtual method. For example, if the analyzed project is distributed as a library or framework, then the end-user could provide a new implementation that returns any value.\n\n\n## Recommendation\nAlways validate the result of virtual methods calls before performing pointer arithmetic to avoid reading or writing outside the bounds of an allocated buffer.\n\n\n## Example\nIn this example, we write to a given element of an array, using an instance of the `PossiblyOverridableClass` to determine which element to write to.\n\nIn the first case, the `GetElementNumber` method is called, and the result is used in pointer arithmetic without any validation. If the user can define a subtype of `PossiblyOverridableClass`, they can create an implementation of `GetElementNumber` that returns an invalid element number. This would lead to a write occurring outside the bounds of the `charArray`.\n\nIn the second case, the result of `GetElementNumber` is stored, and confirmed to be within the bounds of the array. Note that it is not sufficient to check that it is smaller than the length. We must also ensure that it's greater than zero, to prevent writes to locations before the buffer as well as afterwards.\n\n\n```csharp\npublic class PossiblyOverridable\n{\n    public virtual int GetElementNumber()\n    {\n        // By default returns 0, which is safe\n        return 0;\n    }\n}\n\npublic class PointerArithmetic\n{\n    public unsafe void WriteToOffset(PossiblyOverridable possiblyOverridable,\n                                     char[] charArray)\n    {\n        fixed (char* charPointer = charArray)\n        {\n            // BAD: Unvalidated use of virtual method call result in pointer arithmetic\n            char* newCharPointer = charPointer + possiblyOverridable.GetElementNumber();\n            *newCharPointer = 'A';\n            // GOOD: Check that the number is viable\n            int number = possiblyOverridable.GetElementNumber();\n            if (number >= 0 && number < charArray.Length)\n            {\n                char* newCharPointer2 = charPointer + number;\n                *newCharPointer = 'A';\n            }\n        }\n    }\n}\n\n```\n\n## References\n* Microsoft: [Unsafe Code and Pointers](https://msdn.microsoft.com/en-us/library/t2yzs44b.aspx).\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-122](https://cwe.mitre.org/data/definitions/122.html).\n* Common Weakness Enumeration: [CWE-788](https://cwe.mitre.org/data/definitions/788.html).\n",
                  "markdown": "# Unvalidated local pointer arithmetic\nIt is dangerous to use the result of a virtual method call in pointer arithmetic without validation if external users can provide their own implementation of the virtual method. For example, if the analyzed project is distributed as a library or framework, then the end-user could provide a new implementation that returns any value.\n\n\n## Recommendation\nAlways validate the result of virtual methods calls before performing pointer arithmetic to avoid reading or writing outside the bounds of an allocated buffer.\n\n\n## Example\nIn this example, we write to a given element of an array, using an instance of the `PossiblyOverridableClass` to determine which element to write to.\n\nIn the first case, the `GetElementNumber` method is called, and the result is used in pointer arithmetic without any validation. If the user can define a subtype of `PossiblyOverridableClass`, they can create an implementation of `GetElementNumber` that returns an invalid element number. This would lead to a write occurring outside the bounds of the `charArray`.\n\nIn the second case, the result of `GetElementNumber` is stored, and confirmed to be within the bounds of the array. Note that it is not sufficient to check that it is smaller than the length. We must also ensure that it's greater than zero, to prevent writes to locations before the buffer as well as afterwards.\n\n\n```csharp\npublic class PossiblyOverridable\n{\n    public virtual int GetElementNumber()\n    {\n        // By default returns 0, which is safe\n        return 0;\n    }\n}\n\npublic class PointerArithmetic\n{\n    public unsafe void WriteToOffset(PossiblyOverridable possiblyOverridable,\n                                     char[] charArray)\n    {\n        fixed (char* charPointer = charArray)\n        {\n            // BAD: Unvalidated use of virtual method call result in pointer arithmetic\n            char* newCharPointer = charPointer + possiblyOverridable.GetElementNumber();\n            *newCharPointer = 'A';\n            // GOOD: Check that the number is viable\n            int number = possiblyOverridable.GetElementNumber();\n            if (number >= 0 && number < charArray.Length)\n            {\n                char* newCharPointer2 = charPointer + number;\n                *newCharPointer = 'A';\n            }\n        }\n    }\n}\n\n```\n\n## References\n* Microsoft: [Unsafe Code and Pointers](https://msdn.microsoft.com/en-us/library/t2yzs44b.aspx).\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-122](https://cwe.mitre.org/data/definitions/122.html).\n* Common Weakness Enumeration: [CWE-788](https://cwe.mitre.org/data/definitions/788.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-119",
                    "external/cwe/cwe-120",
                    "external/cwe/cwe-122",
                    "external/cwe/cwe-788"
                  ],
                  "description": "Using the result of a virtual method call in pointer arithmetic without\n              validation is dangerous because the method may be overridden by a subtype\n              to return any value.",
                  "id": "cs/unvalidated-local-pointer-arithmetic",
                  "kind": "problem",
                  "name": "Unvalidated local pointer arithmetic",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "9.3"
                }
              },
              {
                "id": "cs/uncontrolled-format-string",
                "name": "cs/uncontrolled-format-string",
                "shortDescription": {
                  "text": "Uncontrolled format string"
                },
                "fullDescription": {
                  "text": "Passing untrusted format strings from remote data sources can throw exceptions and cause a denial of service."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Uncontrolled format string\nPassing untrusted format strings to `String.Format` can throw exceptions and cause a denial of service. For example, if the format string references a missing argument, or an argument of the wrong type, then `System.FormatException` is thrown.\n\n\n## Recommendation\nUse a string literal for the format string to prevent the possibility of data flow from an untrusted source. This also helps to prevent errors where the arguments to `String.Format` do not match the format string.\n\nIf the format string cannot be constant, ensure that it comes from a secure data source or is compiled into the source code.\n\n\n## Example\nIn this example, the format string is read from an HTTP request, which could cause the application to crash.\n\n\n```csharp\nusing System.Web;\n\npublic class HttpHandler : IHttpHandler\n{\n    string Surname, Forenames, FormattedName;\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string format = ctx.Request.QueryString[\"nameformat\"];\n\n        // BAD: Uncontrolled format string.\n        FormattedName = string.Format(format, Surname, Forenames);\n    }\n}\n\n```\n\n## References\n* OWASP: [Format string attack](https://www.owasp.org/index.php/Format_string_attack).\n* Microsoft docs: [String.Format Method](https://docs.microsoft.com/en-us/dotnet/api/system.string.format)\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n",
                  "markdown": "# Uncontrolled format string\nPassing untrusted format strings to `String.Format` can throw exceptions and cause a denial of service. For example, if the format string references a missing argument, or an argument of the wrong type, then `System.FormatException` is thrown.\n\n\n## Recommendation\nUse a string literal for the format string to prevent the possibility of data flow from an untrusted source. This also helps to prevent errors where the arguments to `String.Format` do not match the format string.\n\nIf the format string cannot be constant, ensure that it comes from a secure data source or is compiled into the source code.\n\n\n## Example\nIn this example, the format string is read from an HTTP request, which could cause the application to crash.\n\n\n```csharp\nusing System.Web;\n\npublic class HttpHandler : IHttpHandler\n{\n    string Surname, Forenames, FormattedName;\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string format = ctx.Request.QueryString[\"nameformat\"];\n\n        // BAD: Uncontrolled format string.\n        FormattedName = string.Format(format, Surname, Forenames);\n    }\n}\n\n```\n\n## References\n* OWASP: [Format string attack](https://www.owasp.org/index.php/Format_string_attack).\n* Microsoft docs: [String.Format Method](https://docs.microsoft.com/en-us/dotnet/api/system.string.format)\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-134"
                  ],
                  "description": "Passing untrusted format strings from remote data sources can throw exceptions\n              and cause a denial of service.",
                  "id": "cs/uncontrolled-format-string",
                  "kind": "path-problem",
                  "name": "Uncontrolled format string",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.3"
                }
              },
              {
                "id": "cs/sensitive-data-transmission",
                "name": "cs/sensitive-data-transmission",
                "shortDescription": {
                  "text": "Information exposure through transmitted data"
                },
                "fullDescription": {
                  "text": "Transmitting sensitive information to the user is a potential security risk."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Information exposure through transmitted data\nTransmitting sensitive data to the user is a potential security risk. Always ensure that transmitted data is intended for the user. For example, passwords and the contents of database exceptions are generally not appropriate to send to the user, as they reveal information that could be abused or exploited.\n\n\n## Recommendation\nAvoid transmitting passwords or exceptions to the user. Instead, create a more user-friendly message that does not contain potentially sensitive information. Technical errors should be written to a log file.\n\n\n## Example\nThe following example shows the user password being sent back to the user.\n\n\n```csharp\npublic class Handler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        try\n        {\n       ...\n    }\n        catch (AuthenticationFailure ex)\n        {\n            ctx.Response.Write(\"Invalid password: \" + password);\n        }\n    }\n}\n\n```\nThe following example shows a database exception being sent to the user. Exceptions can often contain unnecessary technical or sensitive information that should not be seen by the user.\n\n\n```csharp\npublic class Handler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        try\n        {\n       ...\n    }\n        catch (DbException ex)\n        {\n            ctx.Response.Write(\"Database error: \" + ex.Message);\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Sensitive Data Exposure](https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure).\n* Common Weakness Enumeration: [CWE-201](https://cwe.mitre.org/data/definitions/201.html).\n",
                  "markdown": "# Information exposure through transmitted data\nTransmitting sensitive data to the user is a potential security risk. Always ensure that transmitted data is intended for the user. For example, passwords and the contents of database exceptions are generally not appropriate to send to the user, as they reveal information that could be abused or exploited.\n\n\n## Recommendation\nAvoid transmitting passwords or exceptions to the user. Instead, create a more user-friendly message that does not contain potentially sensitive information. Technical errors should be written to a log file.\n\n\n## Example\nThe following example shows the user password being sent back to the user.\n\n\n```csharp\npublic class Handler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        try\n        {\n       ...\n    }\n        catch (AuthenticationFailure ex)\n        {\n            ctx.Response.Write(\"Invalid password: \" + password);\n        }\n    }\n}\n\n```\nThe following example shows a database exception being sent to the user. Exceptions can often contain unnecessary technical or sensitive information that should not be seen by the user.\n\n\n```csharp\npublic class Handler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        try\n        {\n       ...\n    }\n        catch (DbException ex)\n        {\n            ctx.Response.Write(\"Database error: \" + ex.Message);\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [Sensitive Data Exposure](https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure).\n* Common Weakness Enumeration: [CWE-201](https://cwe.mitre.org/data/definitions/201.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-201"
                  ],
                  "description": "Transmitting sensitive information to the user is a potential security risk.",
                  "id": "cs/sensitive-data-transmission",
                  "kind": "path-problem",
                  "name": "Information exposure through transmitted data",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "4.3"
                }
              },
              {
                "id": "cs/information-exposure-through-exception",
                "name": "cs/information-exposure-through-exception",
                "shortDescription": {
                  "text": "Information exposure through an exception"
                },
                "fullDescription": {
                  "text": "Leaking information about an exception, such as messages and stack traces, to an external user can expose implementation details that are useful to an attacker for developing a subsequent exploit."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Information exposure through an exception\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user by calling `ToString()`, and writing it to the response. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class StackTraceHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        try\n        {\n            doSomeWork();\n        }\n        catch (Exception ex)\n        {\n            // BAD: printing a stack trace back to the response\n            ctx.Response.Write(ex.ToString());\n            return;\n        }\n\n        try\n        {\n            doSomeWork();\n        }\n        catch (Exception ex)\n        {\n            // GOOD: log the stack trace, and send back a non-revealing response\n            log(\"Exception occurred\", ex);\n            ctx.Response.Write(\"Exception occurred\");\n            return;\n        }\n    }\n}\n\n```\n",
                  "markdown": "# Information exposure through an exception\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user by calling `ToString()`, and writing it to the response. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class StackTraceHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        try\n        {\n            doSomeWork();\n        }\n        catch (Exception ex)\n        {\n            // BAD: printing a stack trace back to the response\n            ctx.Response.Write(ex.ToString());\n            return;\n        }\n\n        try\n        {\n            doSomeWork();\n        }\n        catch (Exception ex)\n        {\n            // GOOD: log the stack trace, and send back a non-revealing response\n            log(\"Exception occurred\", ex);\n            ctx.Response.Write(\"Exception occurred\");\n            return;\n        }\n    }\n}\n\n```\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-209",
                    "external/cwe/cwe-497"
                  ],
                  "description": "Leaking information about an exception, such as messages and stack traces, to an\n              external user can expose implementation details that are useful to an attacker for\n              developing a subsequent exploit.",
                  "id": "cs/information-exposure-through-exception",
                  "kind": "path-problem",
                  "name": "Information exposure through an exception",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "5.4"
                }
              },
              {
                "id": "cs/web/missing-global-error-handler",
                "name": "cs/web/missing-global-error-handler",
                "shortDescription": {
                  "text": "Missing global error handler"
                },
                "fullDescription": {
                  "text": "ASP.NET applications should not set the 'customError' mode to \"off\" without providing a global error handler, otherwise they may leak exception information."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Missing global error handler\n`Web.config` files that set the `customErrors` mode to `Off` and do not provide an `Application_Error` method in the `global.asax.cs` file rely on the default error pages, which leak information such as stack traces.\n\n\n## Recommendation\nSet the `customErrors` to `On` to prevent the default error page from being displayed, or to `RemoteOnly` to only show the default error page when the application is accessed locally. Alternatively, provide an implementation of the `Application_Error` method in the `global.asax.cs` page.\n\n\n## Example\nThe following example shows a `Web.config` file in which the custom errors mode has been set to `Off`.\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <customErrors mode=\"Off\">\n      ...\n    </customErrors>\n  </system.web>\n</configuration>\n\n```\nThis can be fixed either by specifying a different mode, such as `On`, in the `Web.config` file:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <customErrors mode=\"On\">\n      ...\n    </customErrors>\n  </system.web>\n</configuration>\n\n```\nor by defining an `Application_Error` method in the `global.asax.cs` file:\n\n\n```csharp\nusing System;\nusing System.Web;\n\nnamespace WebApp\n{\n    public class Global : HttpApplication\n    {\n        void Application_Error(object sender, EventArgs e)\n        {\n            // Handle errors here\n        }\n    }\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-12](https://cwe.mitre.org/data/definitions/12.html).\n* Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).\n",
                  "markdown": "# Missing global error handler\n`Web.config` files that set the `customErrors` mode to `Off` and do not provide an `Application_Error` method in the `global.asax.cs` file rely on the default error pages, which leak information such as stack traces.\n\n\n## Recommendation\nSet the `customErrors` to `On` to prevent the default error page from being displayed, or to `RemoteOnly` to only show the default error page when the application is accessed locally. Alternatively, provide an implementation of the `Application_Error` method in the `global.asax.cs` page.\n\n\n## Example\nThe following example shows a `Web.config` file in which the custom errors mode has been set to `Off`.\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <customErrors mode=\"Off\">\n      ...\n    </customErrors>\n  </system.web>\n</configuration>\n\n```\nThis can be fixed either by specifying a different mode, such as `On`, in the `Web.config` file:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <customErrors mode=\"On\">\n      ...\n    </customErrors>\n  </system.web>\n</configuration>\n\n```\nor by defining an `Application_Error` method in the `global.asax.cs` file:\n\n\n```csharp\nusing System;\nusing System.Web;\n\nnamespace WebApp\n{\n    public class Global : HttpApplication\n    {\n        void Application_Error(object sender, EventArgs e)\n        {\n            // Handle errors here\n        }\n    }\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-12](https://cwe.mitre.org/data/definitions/12.html).\n* Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-12",
                    "external/cwe/cwe-248"
                  ],
                  "description": "ASP.NET applications should not set the 'customError' mode to \"off\" without providing\n              a global error handler, otherwise they may leak exception information.",
                  "id": "cs/web/missing-global-error-handler",
                  "kind": "problem",
                  "name": "Missing global error handler",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/cleartext-storage-of-sensitive-information",
                "name": "cs/cleartext-storage-of-sensitive-information",
                "shortDescription": {
                  "text": "Clear text storage of sensitive information"
                },
                "fullDescription": {
                  "text": "Sensitive information stored without encryption or hashing can expose it to an attacker."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Clear text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. For ASP.NET applications, the `System.Web.Security.MachineKey` class may be used to encode sensitive information.\n\nIf possible, avoid placing sensitive information in cookies all together. Instead, prefer storing a key in the cookie that can be used to lookup the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a cookie. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are protected before storing them, using `MachineKey.Protect`, wrapped in a utility method.\n\n\n```csharp\nusing System.Text;\nusing System.Web;\nusing System.Web.Security;\n\npublic class CleartextStorageHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string accountName = ctx.Request.QueryString[\"AccountName\"];\n        // BAD: Setting a cookie value with cleartext sensitive data.\n        ctx.Response.Cookies[\"AccountName\"].Value = accountName;\n        // GOOD: Encoding the value before setting it.\n        ctx.Response.Cookies[\"AccountName\"].Value = Protect(accountName, \"Account name\");\n    }\n\n    /// <summary>\n    /// Protect the cleartext value, using the given type.\n    /// </summary>\n    /// <value>\n    /// The protected value, which is no longer cleartext.\n    /// </value>\n    public string Protect(string value, string type)\n    {\n        return Encoding.UTF8.GetString(MachineKey.Protect(Encoding.UTF8.GetBytes(value), type));\n    }\n}\n\n```\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n",
                  "markdown": "# Clear text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. For ASP.NET applications, the `System.Web.Security.MachineKey` class may be used to encode sensitive information.\n\nIf possible, avoid placing sensitive information in cookies all together. Instead, prefer storing a key in the cookie that can be used to lookup the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a cookie. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are protected before storing them, using `MachineKey.Protect`, wrapped in a utility method.\n\n\n```csharp\nusing System.Text;\nusing System.Web;\nusing System.Web.Security;\n\npublic class CleartextStorageHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string accountName = ctx.Request.QueryString[\"AccountName\"];\n        // BAD: Setting a cookie value with cleartext sensitive data.\n        ctx.Response.Cookies[\"AccountName\"].Value = accountName;\n        // GOOD: Encoding the value before setting it.\n        ctx.Response.Cookies[\"AccountName\"].Value = Protect(accountName, \"Account name\");\n    }\n\n    /// <summary>\n    /// Protect the cleartext value, using the given type.\n    /// </summary>\n    /// <value>\n    /// The protected value, which is no longer cleartext.\n    /// </value>\n    public string Protect(string value, string type)\n    {\n        return Encoding.UTF8.GetString(MachineKey.Protect(Encoding.UTF8.GetBytes(value), type));\n    }\n}\n\n```\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-312",
                    "external/cwe/cwe-315",
                    "external/cwe/cwe-359"
                  ],
                  "description": "Sensitive information stored without encryption or hashing can expose it to an\n              attacker.",
                  "id": "cs/cleartext-storage-of-sensitive-information",
                  "kind": "path-problem",
                  "name": "Clear text storage of sensitive information",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/web/missing-token-validation",
                "name": "cs/web/missing-token-validation",
                "shortDescription": {
                  "text": "Missing cross-site request forgery token validation"
                },
                "fullDescription": {
                  "text": "Handling a POST request without verifying that the request came from the user allows a malicious attacker to submit a request on behalf of the user."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Missing cross-site request forgery token validation\nWeb applications that use tokens to prevent cross-site request forgery (CSRF) should validate the tokens for all Http POST requests.\n\nAlthough login and authentication methods are not vulnerable to traditional CSRF attacks, they still need to be protected with a token or other mitigation. This because an unprotected login page can be used by an attacker to force a login using an account controlled by the attacker. Subsequent requests to the site are then made using this account, without the user being aware that this is the case. This can result in the user associating private information with the attacker-controlled account.\n\n\n## Recommendation\nThe appropriate attribute should be added to this method to ensure the anti-forgery token is validated when this action method is called. If using the MVC-provided anti-forgery framework this will be the `[ValidateAntiForgeryToken]` attribute.\n\nAlternatively, you may consider including a global filter that applies token validation to all POST requests.\n\n\n## Example\nIn the following example an ASP.NET MVC `Controller` is using the `[ValidateAntiForgeryToken]` attribute to mitigate against CSRF attacks. It has been applied correctly to the `UpdateDetails` method. However, this attribute has not been applied to the `Login` method. This should be fixed by adding this attribute.\n\n\n```csharp\nusing System.Web.Mvc;\n\npublic class HomeController : Controller\n{\n    // BAD: Anti forgery token has been forgotten\n    [HttpPost]\n    public ActionResult Login()\n    {\n        return View();\n    }\n\n    // GOOD: Anti forgery token is validated\n    [HttpPost]\n    [ValidateAntiForgeryToken]\n    public ActionResult UpdateDetails()\n    {\n        return View();\n    }\n}\n\n```\n\n## References\n* Wikipedia: [Cross-Site Request Forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery).\n* Microsoft Docs: [XSRF/CSRF Prevention in ASP.NET MVC and Web Pages](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages).\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n",
                  "markdown": "# Missing cross-site request forgery token validation\nWeb applications that use tokens to prevent cross-site request forgery (CSRF) should validate the tokens for all Http POST requests.\n\nAlthough login and authentication methods are not vulnerable to traditional CSRF attacks, they still need to be protected with a token or other mitigation. This because an unprotected login page can be used by an attacker to force a login using an account controlled by the attacker. Subsequent requests to the site are then made using this account, without the user being aware that this is the case. This can result in the user associating private information with the attacker-controlled account.\n\n\n## Recommendation\nThe appropriate attribute should be added to this method to ensure the anti-forgery token is validated when this action method is called. If using the MVC-provided anti-forgery framework this will be the `[ValidateAntiForgeryToken]` attribute.\n\nAlternatively, you may consider including a global filter that applies token validation to all POST requests.\n\n\n## Example\nIn the following example an ASP.NET MVC `Controller` is using the `[ValidateAntiForgeryToken]` attribute to mitigate against CSRF attacks. It has been applied correctly to the `UpdateDetails` method. However, this attribute has not been applied to the `Login` method. This should be fixed by adding this attribute.\n\n\n```csharp\nusing System.Web.Mvc;\n\npublic class HomeController : Controller\n{\n    // BAD: Anti forgery token has been forgotten\n    [HttpPost]\n    public ActionResult Login()\n    {\n        return View();\n    }\n\n    // GOOD: Anti forgery token is validated\n    [HttpPost]\n    [ValidateAntiForgeryToken]\n    public ActionResult UpdateDetails()\n    {\n        return View();\n    }\n}\n\n```\n\n## References\n* Wikipedia: [Cross-Site Request Forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery).\n* Microsoft Docs: [XSRF/CSRF Prevention in ASP.NET MVC and Web Pages](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages).\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-352"
                  ],
                  "description": "Handling a POST request without verifying that the request came from the user\n              allows a malicious attacker to submit a request on behalf of the user.",
                  "id": "cs/web/missing-token-validation",
                  "kind": "problem",
                  "name": "Missing cross-site request forgery token validation",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "8.8"
                }
              },
              {
                "id": "cs/exposure-of-sensitive-information",
                "name": "cs/exposure-of-sensitive-information",
                "shortDescription": {
                  "text": "Exposure of private information"
                },
                "fullDescription": {
                  "text": "If private information is written to an external location, it may be accessible by unauthorized persons."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Exposure of private information\nPrivate information that is stored in an external location may be more vulnerable because that location may not be protected by the same access controls as other parts of the system.\n\nExamples include log files, cookies and plain text storage on disk.\n\n\n## Recommendation\nEnsure that private information is only stored in secure data locations.\n\n\n## Example\nThe following example shows some private data - an address - being passed to a HTTP handler. This private information is then stored in a log file. This log file on disk may be accessible to users that do not normally have access to this private data.\n\n\n```csharp\nusing System.Text;\nusing System.Web;\nusing System.Web.Security;\n\npublic class PrivateInformationHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string address = ctx.Request.QueryString[\"Address1\"];\n        logger.Info(\"User has address: \" + address);\n    }\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n",
                  "markdown": "# Exposure of private information\nPrivate information that is stored in an external location may be more vulnerable because that location may not be protected by the same access controls as other parts of the system.\n\nExamples include log files, cookies and plain text storage on disk.\n\n\n## Recommendation\nEnsure that private information is only stored in secure data locations.\n\n\n## Example\nThe following example shows some private data - an address - being passed to a HTTP handler. This private information is then stored in a log file. This log file on disk may be accessible to users that do not normally have access to this private data.\n\n\n```csharp\nusing System.Text;\nusing System.Web;\nusing System.Web.Security;\n\npublic class PrivateInformationHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string address = ctx.Request.QueryString[\"Address1\"];\n        logger.Info(\"User has address: \" + address);\n    }\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-359"
                  ],
                  "description": "If private information is written to an external location, it may be accessible by\n              unauthorized persons.",
                  "id": "cs/exposure-of-sensitive-information",
                  "kind": "path-problem",
                  "name": "Exposure of private information",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "6.5"
                }
              },
              {
                "id": "cs/session-reuse",
                "name": "cs/session-reuse",
                "shortDescription": {
                  "text": "Failure to abandon session"
                },
                "fullDescription": {
                  "text": "Reusing an existing session as a different user could allow an attacker to access someone else's account by using their session."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Failure to abandon session\nReusing a session could allow an attacker to gain unauthorized access to another account. Always ensure that, when a user logs in or out, the current session is abandoned so that a new session may be started.\n\n\n## Recommendation\nAlways call `HttpSessionState.Abandon()` to ensure that the previous session is not used by the new user.\n\n\n## Example\nThe following example shows the previous session being used after authentication. This would allow a previous user to use the new user's account.\n\n\n```csharp\npublic void Login(HttpContext ctx, string username, string password)\n{\n    if (FormsAuthentication.Authenticate(username, password)\n    {\n        // BAD: Reusing the previous session\n        ctx.Session[\"Mode\"] = GetModeForUser(username);\n    }\n}\n\n```\nThis code example solves the problem by not reusing the session, and instead calling `Abandon()` to ensure that the session is not reused.\n\n\n```csharp\npublic void Login(HttpContext ctx, string username, string password)\n{\n    if (FormsAuthentication.Authenticate(username, password)\n    {\n        // GOOD: Abandon the session first.\n        ctx.Session.Abandon();\n    }\n}\n\n```\n\n## References\n* MSDN: [ASP.NET Session State Overview](https://msdn.microsoft.com/en-us/library/ms178581.aspx), [HttpSessionState.Abandon Method ()](https://msdn.microsoft.com/en-us/library/system.web.sessionstate.httpsessionstate.abandon(v=vs.110).aspx).\n* Common Weakness Enumeration: [CWE-384](https://cwe.mitre.org/data/definitions/384.html).\n",
                  "markdown": "# Failure to abandon session\nReusing a session could allow an attacker to gain unauthorized access to another account. Always ensure that, when a user logs in or out, the current session is abandoned so that a new session may be started.\n\n\n## Recommendation\nAlways call `HttpSessionState.Abandon()` to ensure that the previous session is not used by the new user.\n\n\n## Example\nThe following example shows the previous session being used after authentication. This would allow a previous user to use the new user's account.\n\n\n```csharp\npublic void Login(HttpContext ctx, string username, string password)\n{\n    if (FormsAuthentication.Authenticate(username, password)\n    {\n        // BAD: Reusing the previous session\n        ctx.Session[\"Mode\"] = GetModeForUser(username);\n    }\n}\n\n```\nThis code example solves the problem by not reusing the session, and instead calling `Abandon()` to ensure that the session is not reused.\n\n\n```csharp\npublic void Login(HttpContext ctx, string username, string password)\n{\n    if (FormsAuthentication.Authenticate(username, password)\n    {\n        // GOOD: Abandon the session first.\n        ctx.Session.Abandon();\n    }\n}\n\n```\n\n## References\n* MSDN: [ASP.NET Session State Overview](https://msdn.microsoft.com/en-us/library/ms178581.aspx), [HttpSessionState.Abandon Method ()](https://msdn.microsoft.com/en-us/library/system.web.sessionstate.httpsessionstate.abandon(v=vs.110).aspx).\n* Common Weakness Enumeration: [CWE-384](https://cwe.mitre.org/data/definitions/384.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-384"
                  ],
                  "description": "Reusing an existing session as a different user could allow\n              an attacker to access someone else's account by using\n              their session.",
                  "id": "cs/session-reuse",
                  "kind": "problem",
                  "name": "Failure to abandon session",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "8.8"
                }
              },
              {
                "id": "cs/web/missing-x-frame-options",
                "name": "cs/web/missing-x-frame-options",
                "shortDescription": {
                  "text": "Missing X-Frame-Options HTTP header"
                },
                "fullDescription": {
                  "text": "If the 'X-Frame-Options' setting is not provided, a malicious user may be able to overlay their own UI on top of the site by using an iframe."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Missing X-Frame-Options HTTP header\nWeb sites that do not specify the `X-Frame-Options` HTTP header may be vulnerable to UI redress attacks (\"clickjacking\"). In these attacks, the vulnerable site is loaded in a frame on an attacker-controlled site which uses opaque or transparent layers to trick the user into unintentionally clicking a button or link on the vulnerable site.\n\n\n## Recommendation\nSet the `X-Frame-Options` HTTP header to `DENY`, to instruct web browsers to block attempts to load the site in a frame. Alternatively, if framing is needed in certain circumstances, specify `SAMEORIGIN` or `ALLOW FROM: ...` to limit the ability to frame the site to pages from the same origin, or from an allowed whitelist of trusted domains.\n\nFor ASP.NET web applications, the header may be specified either in the `Web.config` file, using the `<customHeaders>` tag, or within the source code of the application using the `HttpResponse.AddHeader` method. In general, prefer specifying the header in the `Web.config` file to ensure it is added to all requests. If adding it to the source code, ensure that it is added unconditionally to all requests. For example, add the header in the `Application_BeginRequest` method in the `global.asax` file.\n\n\n## Example\nThe following example shows how to specify the `X-Frame-Options` header within the `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n  </system.web>\n  <system.webServer>\n    <httpProtocol>\n      <customHeaders>\n        <add name=\"X-Frame-Options\" value=\"SAMEORIGIN\" />\n      </customHeaders>\n    </httpProtocol>\n  </system.webServer>\n</configuration>\n\n```\nThis next example shows how to specify the `X-Frame-Options` header within the `global.asax` file for ASP.NET application:\n\n\n```csharp\nprotected void Application_BeginRequest(object sender, EventArgs e)\n{\n    HttpContext.Current.Response.AddHeader(\"X-Frame-Options\", \"DENY\");\n}\n\n```\n\n## References\n* OWASP: [Clickjacking Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html).\n* Mozilla: [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)\n* Common Weakness Enumeration: [CWE-451](https://cwe.mitre.org/data/definitions/451.html).\n* Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).\n",
                  "markdown": "# Missing X-Frame-Options HTTP header\nWeb sites that do not specify the `X-Frame-Options` HTTP header may be vulnerable to UI redress attacks (\"clickjacking\"). In these attacks, the vulnerable site is loaded in a frame on an attacker-controlled site which uses opaque or transparent layers to trick the user into unintentionally clicking a button or link on the vulnerable site.\n\n\n## Recommendation\nSet the `X-Frame-Options` HTTP header to `DENY`, to instruct web browsers to block attempts to load the site in a frame. Alternatively, if framing is needed in certain circumstances, specify `SAMEORIGIN` or `ALLOW FROM: ...` to limit the ability to frame the site to pages from the same origin, or from an allowed whitelist of trusted domains.\n\nFor ASP.NET web applications, the header may be specified either in the `Web.config` file, using the `<customHeaders>` tag, or within the source code of the application using the `HttpResponse.AddHeader` method. In general, prefer specifying the header in the `Web.config` file to ensure it is added to all requests. If adding it to the source code, ensure that it is added unconditionally to all requests. For example, add the header in the `Application_BeginRequest` method in the `global.asax` file.\n\n\n## Example\nThe following example shows how to specify the `X-Frame-Options` header within the `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n  </system.web>\n  <system.webServer>\n    <httpProtocol>\n      <customHeaders>\n        <add name=\"X-Frame-Options\" value=\"SAMEORIGIN\" />\n      </customHeaders>\n    </httpProtocol>\n  </system.webServer>\n</configuration>\n\n```\nThis next example shows how to specify the `X-Frame-Options` header within the `global.asax` file for ASP.NET application:\n\n\n```csharp\nprotected void Application_BeginRequest(object sender, EventArgs e)\n{\n    HttpContext.Current.Response.AddHeader(\"X-Frame-Options\", \"DENY\");\n}\n\n```\n\n## References\n* OWASP: [Clickjacking Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html).\n* Mozilla: [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)\n* Common Weakness Enumeration: [CWE-451](https://cwe.mitre.org/data/definitions/451.html).\n* Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-451",
                    "external/cwe/cwe-829"
                  ],
                  "description": "If the 'X-Frame-Options' setting is not provided, a malicious user may be able to\n              overlay their own UI on top of the site by using an iframe.",
                  "id": "cs/web/missing-x-frame-options",
                  "kind": "problem",
                  "name": "Missing X-Frame-Options HTTP header",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/deserialized-delegate",
                "name": "cs/deserialized-delegate",
                "shortDescription": {
                  "text": "Deserialized delegate"
                },
                "fullDescription": {
                  "text": "Deserializing a delegate allows for remote code execution when an attacker can control the serialized data."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Deserialized delegate\nDeserializing a delegate object may result in remote code execution, when an attacker can control the serialized data.\n\n\n## Recommendation\nAvoid deserializing delegate objects, if possible, or make sure that the serialized data cannot be controlled by an attacker.\n\n\n## Example\nIn this example, a file stream is deserialized to a `Func<int>` object, using a `BinaryFormatter`. The file stream is a parameter of a public method, so depending on the calls to `InvokeSerialized`, this may or may not pose a security problem.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\n\nclass Bad\n{\n    public static int InvokeSerialized(FileStream fs)\n    {\n        var formatter = new BinaryFormatter();\n        // BAD\n        var f = (Func<int>)formatter.Deserialize(fs);\n        return f();\n    }\n}\n\n```\n\n## References\n* Microsoft: [BinaryFormatter Class](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n",
                  "markdown": "# Deserialized delegate\nDeserializing a delegate object may result in remote code execution, when an attacker can control the serialized data.\n\n\n## Recommendation\nAvoid deserializing delegate objects, if possible, or make sure that the serialized data cannot be controlled by an attacker.\n\n\n## Example\nIn this example, a file stream is deserialized to a `Func<int>` object, using a `BinaryFormatter`. The file stream is a parameter of a public method, so depending on the calls to `InvokeSerialized`, this may or may not pose a security problem.\n\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\n\nclass Bad\n{\n    public static int InvokeSerialized(FileStream fs)\n    {\n        var formatter = new BinaryFormatter();\n        // BAD\n        var f = (Func<int>)formatter.Deserialize(fs);\n        return f();\n    }\n}\n\n```\n\n## References\n* Microsoft: [BinaryFormatter Class](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-502"
                  ],
                  "description": "Deserializing a delegate allows for remote code execution when an\n              attacker can control the serialized data.",
                  "id": "cs/deserialized-delegate",
                  "kind": "problem",
                  "name": "Deserialized delegate",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/unsafe-deserialization-untrusted-input",
                "name": "cs/unsafe-deserialization-untrusted-input",
                "shortDescription": {
                  "text": "Deserialization of untrusted data"
                },
                "fullDescription": {
                  "text": "Calling an unsafe deserializer with data controlled by an attacker can lead to denial of service and other security problems."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Deserialization of untrusted data\nDeserializing an object from untrusted input may result in security problems, such as denial of service or remote code execution.\n\n\n## Recommendation\nAvoid deserializing objects from an untrusted source, and if not possible, make sure to use a safe deserialization framework.\n\n\n## Example\nIn this example, text from an HTML text box is deserialized using a `JavaScriptSerializer` with a simple type resolver. Using a type resolver means that arbitrary code may be executed.\n\n\n```csharp\nusing System.Web.UI.WebControls;\nusing System.Web.Script.Serialization;\n\nclass Bad\n{\n    public static object Deserialize(TextBox textBox)\n    {\n        JavaScriptSerializer sr = new JavaScriptSerializer(new SimpleTypeResolver());\n        // BAD\n        return sr.DeserializeObject(textBox.Text);\n    }\n}\n\n```\nTo fix this specific vulnerability, we avoid using a type resolver. In other cases, it may be necessary to use a different deserialization framework.\n\n\n```csharp\nusing System.Web.UI.WebControls;\nusing System.Web.Script.Serialization;\n\nclass Good\n{\n    public static object Deserialize(TextBox textBox)\n    {\n        JavaScriptSerializer sr = new JavaScriptSerializer();\n        // GOOD: no unsafe type resolver\n        return sr.DeserializeObject(textBox.Text);\n    }\n}\n\n```\nIn the following example potentially untrusted stream and type is deserialized using a `DataContractJsonSerializer` which is known to be vulnerable with user supplied types.\n\n\n```csharp\nusing System.Runtime.Serialization.Json;\nusing System.IO;\nusing System;\n\nclass BadDataContractJsonSerializer\n{\n    public static object Deserialize(string type, Stream s)\n    {\n        // BAD: stream and type are potentially untrusted\n        var ds = new DataContractJsonSerializer(Type.GetType(type));\n        return ds.ReadObject(s);\n    }\n}\n\n```\nTo fix this specific vulnerability, we are using hardcoded Plain Old CLR Object ([POCO](https://en.wikipedia.org/wiki/Plain_old_CLR_object)) type. In other cases, it may be necessary to use a different deserialization framework.\n\n\n```csharp\nusing System.Runtime.Serialization.Json;\nusing System.IO;\nusing System;\n\nclass Poco\n{\n    public int Count;\n\n    public string Comment;\n}\n\nclass GoodDataContractJsonSerializer\n{\n    public static Poco Deserialize(Stream s)\n    {\n        // GOOD: while stream is potentially untrusted, the instantiated type is hardcoded\n        var ds = new DataContractJsonSerializer(typeof(Poco));\n        return (Poco)ds.ReadObject(s);\n    }\n}\n\n```\n\n## References\n* Mu&ntilde;oz, Alvaro and Mirosh, Oleksandr: [JSON Attacks](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n",
                  "markdown": "# Deserialization of untrusted data\nDeserializing an object from untrusted input may result in security problems, such as denial of service or remote code execution.\n\n\n## Recommendation\nAvoid deserializing objects from an untrusted source, and if not possible, make sure to use a safe deserialization framework.\n\n\n## Example\nIn this example, text from an HTML text box is deserialized using a `JavaScriptSerializer` with a simple type resolver. Using a type resolver means that arbitrary code may be executed.\n\n\n```csharp\nusing System.Web.UI.WebControls;\nusing System.Web.Script.Serialization;\n\nclass Bad\n{\n    public static object Deserialize(TextBox textBox)\n    {\n        JavaScriptSerializer sr = new JavaScriptSerializer(new SimpleTypeResolver());\n        // BAD\n        return sr.DeserializeObject(textBox.Text);\n    }\n}\n\n```\nTo fix this specific vulnerability, we avoid using a type resolver. In other cases, it may be necessary to use a different deserialization framework.\n\n\n```csharp\nusing System.Web.UI.WebControls;\nusing System.Web.Script.Serialization;\n\nclass Good\n{\n    public static object Deserialize(TextBox textBox)\n    {\n        JavaScriptSerializer sr = new JavaScriptSerializer();\n        // GOOD: no unsafe type resolver\n        return sr.DeserializeObject(textBox.Text);\n    }\n}\n\n```\nIn the following example potentially untrusted stream and type is deserialized using a `DataContractJsonSerializer` which is known to be vulnerable with user supplied types.\n\n\n```csharp\nusing System.Runtime.Serialization.Json;\nusing System.IO;\nusing System;\n\nclass BadDataContractJsonSerializer\n{\n    public static object Deserialize(string type, Stream s)\n    {\n        // BAD: stream and type are potentially untrusted\n        var ds = new DataContractJsonSerializer(Type.GetType(type));\n        return ds.ReadObject(s);\n    }\n}\n\n```\nTo fix this specific vulnerability, we are using hardcoded Plain Old CLR Object ([POCO](https://en.wikipedia.org/wiki/Plain_old_CLR_object)) type. In other cases, it may be necessary to use a different deserialization framework.\n\n\n```csharp\nusing System.Runtime.Serialization.Json;\nusing System.IO;\nusing System;\n\nclass Poco\n{\n    public int Count;\n\n    public string Comment;\n}\n\nclass GoodDataContractJsonSerializer\n{\n    public static Poco Deserialize(Stream s)\n    {\n        // GOOD: while stream is potentially untrusted, the instantiated type is hardcoded\n        var ds = new DataContractJsonSerializer(typeof(Poco));\n        return (Poco)ds.ReadObject(s);\n    }\n}\n\n```\n\n## References\n* Mu&ntilde;oz, Alvaro and Mirosh, Oleksandr: [JSON Attacks](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-502"
                  ],
                  "description": "Calling an unsafe deserializer with data controlled by an attacker\n              can lead to denial of service and other security problems.",
                  "id": "cs/unsafe-deserialization-untrusted-input",
                  "kind": "path-problem",
                  "name": "Deserialization of untrusted data",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/web/directory-browse-enabled",
                "name": "cs/web/directory-browse-enabled",
                "shortDescription": {
                  "text": "ASP.NET config file enables directory browsing"
                },
                "fullDescription": {
                  "text": "Directory browsing should not be enabled in production as it can leak sensitive information."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# ASP.NET config file enables directory browsing\nASP.NET applications that enable directory browsing can leak sensitive information to an attacker. The precise nature of the vulnerability depends on which files are listed and accessible.\n\n\n## Recommendation\nIf this configuration may be used in production, remove the `directoryBrowse` element from the `Web.config` file or set the value to false.\n\n\n## Example\nThe following example shows the `directoryBrowse` `enable` attribute set to true in a `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.webServer>\n    <directoryBrowse enable=\"true\"/>\n   ...\n  </system.web>\n</configuration>\n```\nTo fix this problem, the `enable` attribute should be set to `false`, or the `directoryBrowse` element should be removed completely:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.webServer>\n    <directoryBrowse enable=\"false\"/>\n   ...\n  </system.web>\n</configuration>\n```\n\n## References\n* MSDN: [directoryBrowse element](https://msdn.microsoft.com/en-us/library/ms691327(v=vs.90).aspx).\n* Common Weakness Enumeration: [CWE-548](https://cwe.mitre.org/data/definitions/548.html).\n",
                  "markdown": "# ASP.NET config file enables directory browsing\nASP.NET applications that enable directory browsing can leak sensitive information to an attacker. The precise nature of the vulnerability depends on which files are listed and accessible.\n\n\n## Recommendation\nIf this configuration may be used in production, remove the `directoryBrowse` element from the `Web.config` file or set the value to false.\n\n\n## Example\nThe following example shows the `directoryBrowse` `enable` attribute set to true in a `Web.config` file for ASP.NET:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.webServer>\n    <directoryBrowse enable=\"true\"/>\n   ...\n  </system.web>\n</configuration>\n```\nTo fix this problem, the `enable` attribute should be set to `false`, or the `directoryBrowse` element should be removed completely:\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.webServer>\n    <directoryBrowse enable=\"false\"/>\n   ...\n  </system.web>\n</configuration>\n```\n\n## References\n* MSDN: [directoryBrowse element](https://msdn.microsoft.com/en-us/library/ms691327(v=vs.90).aspx).\n* Common Weakness Enumeration: [CWE-548](https://cwe.mitre.org/data/definitions/548.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-548"
                  ],
                  "description": "Directory browsing should not be enabled in production as it can leak sensitive information.",
                  "id": "cs/web/directory-browse-enabled",
                  "kind": "problem",
                  "name": "ASP.NET config file enables directory browsing",
                  "precision": "very-high",
                  "problem.severity": "warning",
                  "security-severity": "6.5"
                }
              },
              {
                "id": "cs/web/unvalidated-url-redirection",
                "name": "cs/web/unvalidated-url-redirection",
                "shortDescription": {
                  "text": "URL redirection from remote source"
                },
                "fullDescription": {
                  "text": "URL redirection based on unvalidated user input may cause redirection to malicious web sites."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# URL redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks. It also shows how to remedy the problem by validating the user input against a known fixed string.\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class UnvalidatedUrlHandler : IHttpHandler\n{\n    private const String VALID_REDIRECT = \"http://cwe.mitre.org/data/definitions/601.html\";\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // BAD: a request parameter is incorporated without validation into a URL redirect\n        ctx.Response.Redirect(ctx.Request.QueryString[\"page\"]);\n\n        // GOOD: the request parameter is validated against a known fixed string\n        if (VALID_REDIRECT == ctx.Request.QueryString[\"page\"])\n        {\n            ctx.Response.Redirect(VALID_REDIRECT);\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n",
                  "markdown": "# URL redirection from remote source\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks. It also shows how to remedy the problem by validating the user input against a known fixed string.\n\n\n```csharp\nusing System;\nusing System.Web;\n\npublic class UnvalidatedUrlHandler : IHttpHandler\n{\n    private const String VALID_REDIRECT = \"http://cwe.mitre.org/data/definitions/601.html\";\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // BAD: a request parameter is incorporated without validation into a URL redirect\n        ctx.Response.Redirect(ctx.Request.QueryString[\"page\"]);\n\n        // GOOD: the request parameter is validated against a known fixed string\n        if (VALID_REDIRECT == ctx.Request.QueryString[\"page\"])\n        {\n            ctx.Response.Redirect(VALID_REDIRECT);\n        }\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-601"
                  ],
                  "description": "URL redirection based on unvalidated user input\n              may cause redirection to malicious web sites.",
                  "id": "cs/web/unvalidated-url-redirection",
                  "kind": "path-problem",
                  "name": "URL redirection from remote source",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "6.1"
                }
              },
              {
                "id": "cs/xml/insecure-dtd-handling",
                "name": "cs/xml/insecure-dtd-handling",
                "shortDescription": {
                  "text": "Untrusted XML is read insecurely"
                },
                "fullDescription": {
                  "text": "Untrusted XML is read with an insecure resolver and DTD processing enabled."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Untrusted XML is read insecurely\nXML documents can contain Document Type Definitions (DTDs), which may define new XML entities. These can be used to perform Denial of Service (DoS) attacks, or resolve to resources outside the intended sphere of control.\n\n\n## Recommendation\nWhen processing XML documents, ensure that DTD processing is disabled unless absolutely necessary, and if it is necessary, ensure that a secure resolver is used.\n\n\n## Example\nThe following example shows an HTTP request parameter being read directly into an `XmlTextReader`. In the current version of the .NET Framework, `XmlTextReader` has DTD processing enabled by default.\n\n\n```csharp\npublic class XMLHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // BAD: XmlTextReader is insecure by default, and the payload is user-provided data\n        XmlTextReader reader = new XmlTextReader(ctx.Request.QueryString[\"document\"]);\n    ...\n  }\n}\n\n\n```\nThe solution is to set the `DtdProcessing` property to `DtdProcessing.Prohibit`.\n\n\n## References\n* OWASP: [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html).\n* Microsoft Docs: [System.XML: Security considerations](https://msdn.microsoft.com/en-us/library/system.xml.xmlreadersettings(v=vs.110).aspx#Anchor_6).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n",
                  "markdown": "# Untrusted XML is read insecurely\nXML documents can contain Document Type Definitions (DTDs), which may define new XML entities. These can be used to perform Denial of Service (DoS) attacks, or resolve to resources outside the intended sphere of control.\n\n\n## Recommendation\nWhen processing XML documents, ensure that DTD processing is disabled unless absolutely necessary, and if it is necessary, ensure that a secure resolver is used.\n\n\n## Example\nThe following example shows an HTTP request parameter being read directly into an `XmlTextReader`. In the current version of the .NET Framework, `XmlTextReader` has DTD processing enabled by default.\n\n\n```csharp\npublic class XMLHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        // BAD: XmlTextReader is insecure by default, and the payload is user-provided data\n        XmlTextReader reader = new XmlTextReader(ctx.Request.QueryString[\"document\"]);\n    ...\n  }\n}\n\n\n```\nThe solution is to set the `DtdProcessing` property to `DtdProcessing.Prohibit`.\n\n\n## References\n* OWASP: [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html).\n* Microsoft Docs: [System.XML: Security considerations](https://msdn.microsoft.com/en-us/library/system.xml.xmlreadersettings(v=vs.110).aspx#Anchor_6).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-611",
                    "external/cwe/cwe-827",
                    "external/cwe/cwe-776"
                  ],
                  "description": "Untrusted XML is read with an insecure resolver and DTD processing enabled.",
                  "id": "cs/xml/insecure-dtd-handling",
                  "kind": "path-problem",
                  "name": "Untrusted XML is read insecurely",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.1"
                }
              },
              {
                "id": "cs/web/requiressl-not-set",
                "name": "cs/web/requiressl-not-set",
                "shortDescription": {
                  "text": "'requireSSL' attribute is not set to true"
                },
                "fullDescription": {
                  "text": "Omitting the 'requireSSL' attribute allows data to be transmitted insecurely using HTTP. Always set 'requireSSL' to 'true' to ensure that HTTPS is used at all times."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# 'requireSSL' attribute is not set to true\nSensitive data that is transmitted using HTTP is vulnerable to being read by a third party. By default, web forms and cookies are sent via HTTP, not HTTPS. This setting can be changed by setting the `requireSSL` attribute to `\"true\"` in `Web.config`.\n\n\n## Recommendation\nWhen using web forms, ensure that `Web.config` contains a `<forms>` element with the attribute `requireSSL=\"true\"`.\n\nWhen using cookies, ensure that SSL is used, either via the `<forms>` attribute above, or the `<httpCookies>` element, with the attribute `requireSSL=\"true\"`. It is also possible to require cookies to use SSL programmatically, by setting the property `System.Web.HttpCookie.Secure` to `true`.\n\n\n## Example\nThe following example shows where to specify `requireSSL=\"true\"` in a `Web.config` file.\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <authentication>\n      <forms\n        requireSSL=\"true\"\n        ... />\n    </authentication>\n    <httpCookies\n        requireSSL=\"true\"\n        ... />\n  </system.web>\n</configuration>\n\n```\n\n## References\n* MSDN: [HttpCookie.Secure Property](https://msdn.microsoft.com/en-us/library/system.web.httpcookie.secure(v=vs.110).aspx), [FormsAuthentication.RequireSSL Property](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthentication.requiressl(v=vs.110).aspx), [forms Element for authentication](https://msdn.microsoft.com/en-us/library/1d3t3c61(v=vs.100).aspx), [httpCookies Element](https://msdn.microsoft.com/library/ms228262%28v=vs.100%29.aspx).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n",
                  "markdown": "# 'requireSSL' attribute is not set to true\nSensitive data that is transmitted using HTTP is vulnerable to being read by a third party. By default, web forms and cookies are sent via HTTP, not HTTPS. This setting can be changed by setting the `requireSSL` attribute to `\"true\"` in `Web.config`.\n\n\n## Recommendation\nWhen using web forms, ensure that `Web.config` contains a `<forms>` element with the attribute `requireSSL=\"true\"`.\n\nWhen using cookies, ensure that SSL is used, either via the `<forms>` attribute above, or the `<httpCookies>` element, with the attribute `requireSSL=\"true\"`. It is also possible to require cookies to use SSL programmatically, by setting the property `System.Web.HttpCookie.Secure` to `true`.\n\n\n## Example\nThe following example shows where to specify `requireSSL=\"true\"` in a `Web.config` file.\n\n\n```none\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <system.web>\n    <authentication>\n      <forms\n        requireSSL=\"true\"\n        ... />\n    </authentication>\n    <httpCookies\n        requireSSL=\"true\"\n        ... />\n  </system.web>\n</configuration>\n\n```\n\n## References\n* MSDN: [HttpCookie.Secure Property](https://msdn.microsoft.com/en-us/library/system.web.httpcookie.secure(v=vs.110).aspx), [FormsAuthentication.RequireSSL Property](https://msdn.microsoft.com/en-us/library/system.web.security.formsauthentication.requiressl(v=vs.110).aspx), [forms Element for authentication](https://msdn.microsoft.com/en-us/library/1d3t3c61(v=vs.100).aspx), [httpCookies Element](https://msdn.microsoft.com/library/ms228262%28v=vs.100%29.aspx).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-319",
                    "external/cwe/cwe-614"
                  ],
                  "description": "Omitting the 'requireSSL' attribute allows data to be transmitted insecurely\n              using HTTP. Always set 'requireSSL' to 'true' to ensure that HTTPS\n              is used at all times.",
                  "id": "cs/web/requiressl-not-set",
                  "kind": "problem",
                  "name": "'requireSSL' attribute is not set to true",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/xml/xpath-injection",
                "name": "cs/xml/xpath-injection",
                "shortDescription": {
                  "text": "XPath injection"
                },
                "fullDescription": {
                  "text": "Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# XPath injection\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, pre-compile the query and use variable references to include the user input.\n\nWhen using the `System.Xml.XPath` API, this can be done by creating a custom subtype of `System.Xml.Xsl.XsltContext`, and implementing `ResolveVariable(String, String)` to return the user provided data. This custom context can be specified for a given `XPathExpression` using `XPathExpression.SetContext()`. For more details, see the \"User Defined Functions and Variables\" webpage in the list of references.\n\n\n## Example\nIn the first example, the code accepts a user name specified by the user, and uses this unvalidated and unsanitized value in an XPath expression. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.\n\nIn the second example, the XPath expression is a hard-coded string that specifies some variables, which are safely replaced at runtime using a custom `XsltContext` that looks up the variables in an `XsltArgumentList`.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Xml.XPath;\n\npublic class XPathInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userName = ctx.Request.QueryString[\"userName\"];\n\n        // BAD: Use user-provided data directly in an XPath expression\n        string badXPathExpr = \"//users/user[login/text()='\" + userName + \"']/home_dir/text()\";\n        XPathExpression.Compile(badXPathExpr);\n\n        // GOOD: XPath expression uses variables to refer to parameters\n        string xpathExpression = \"//users/user[login/text()=$username]/home_dir/text()\";\n        XPathExpression xpath = XPathExpression.Compile(xpathExpression);\n\n        // Arguments are provided as a XsltArgumentList()\n        XsltArgumentList varList = new XsltArgumentList();\n        varList.AddParam(\"userName\", string.Empty, userName);\n\n        // CustomContext is an application specific class, that looks up variables in the\n        // expression from the varList.\n        CustomContext context = new CustomContext(new NameTable(), varList)\n      xpath.SetContext(context);\n    }\n}\n\n```\n\n## References\n* OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n* OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).\n* MSDN: [User Defined Functions and Variables](https://msdn.microsoft.com/en-us/library/dd567715.aspx).\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n",
                  "markdown": "# XPath injection\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, pre-compile the query and use variable references to include the user input.\n\nWhen using the `System.Xml.XPath` API, this can be done by creating a custom subtype of `System.Xml.Xsl.XsltContext`, and implementing `ResolveVariable(String, String)` to return the user provided data. This custom context can be specified for a given `XPathExpression` using `XPathExpression.SetContext()`. For more details, see the \"User Defined Functions and Variables\" webpage in the list of references.\n\n\n## Example\nIn the first example, the code accepts a user name specified by the user, and uses this unvalidated and unsanitized value in an XPath expression. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.\n\nIn the second example, the XPath expression is a hard-coded string that specifies some variables, which are safely replaced at runtime using a custom `XsltContext` that looks up the variables in an `XsltArgumentList`.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Xml.XPath;\n\npublic class XPathInjectionHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userName = ctx.Request.QueryString[\"userName\"];\n\n        // BAD: Use user-provided data directly in an XPath expression\n        string badXPathExpr = \"//users/user[login/text()='\" + userName + \"']/home_dir/text()\";\n        XPathExpression.Compile(badXPathExpr);\n\n        // GOOD: XPath expression uses variables to refer to parameters\n        string xpathExpression = \"//users/user[login/text()=$username]/home_dir/text()\";\n        XPathExpression xpath = XPathExpression.Compile(xpathExpression);\n\n        // Arguments are provided as a XsltArgumentList()\n        XsltArgumentList varList = new XsltArgumentList();\n        varList.AddParam(\"userName\", string.Empty, userName);\n\n        // CustomContext is an application specific class, that looks up variables in the\n        // expression from the varList.\n        CustomContext context = new CustomContext(new NameTable(), varList)\n      xpath.SetContext(context);\n    }\n}\n\n```\n\n## References\n* OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n* OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).\n* MSDN: [User Defined Functions and Variables](https://msdn.microsoft.com/en-us/library/dd567715.aspx).\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-643"
                  ],
                  "description": "Building an XPath expression from user-controlled sources is vulnerable to insertion of\n              malicious code by the user.",
                  "id": "cs/xml/xpath-injection",
                  "kind": "path-problem",
                  "name": "XPath injection",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/redos",
                "name": "cs/redos",
                "shortDescription": {
                  "text": "Denial of Service from comparison of user input against expensive regex"
                },
                "fullDescription": {
                  "text": "User input should not be matched against a regular expression that could require exponential time on certain input."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Denial of Service from comparison of user input against expensive regex\nMatching user input against a regular expression which takes exponential time in the worst case can allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting input that takes a long time to execute.\n\nMost regular expression engines, including the C\\# standard library implementation, are designed to work with an extended regular expression syntax. Although this provides flexibility for the user, it can prevent the engine from constructing an efficient implementation of the matcher in all circumstances. In particular, the \"worst case time complexity\" (see the references) of certain regular expressions may be \"exponential\". This would allow a malicious user to provide some input which causes the regular expression to take a very long time to execute.\n\nTypically, a regular expression is vulnerable to this attack if it applies repetition to a sub-expression which itself is repeated, or contains overlapping options. For example, `(a+)+` is vulnerable to a string such as `aaaaaaaaaaaaaaaaaaaaaaaaaaab`. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to avoid the exponential worst case time. If this is not possible, then a timeout should be used to avoid a denial of service. For C\\# applications, a timeout can be provided to the `Regex` constructor. Alternatively, apply a global timeout by setting the `REGEX_DEFAULT_MATCH_TIMEOUT` application domain property, using the `AppDomain.SetData` method.\n\n\n## Example\nThe following example shows a HTTP request parameter that is matched against a regular expression which has exponential worst case performance. In the first case, it is matched without a timeout, which can lead to a denial of service. In the second case, a timeout is used to cancel the evaluation of the regular expression after 1 second.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Text.RegularExpressions;\n\npublic class ReDoSHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userInput = ctx.Request.QueryString[\"userInput\"];\n\n        // BAD: User input is matched against a regex with exponential worst case behavior\n        new Regex(\"^([a-z]*)*$\").Match(userInput);\n\n        // GOOD: Regex is given a timeout to avoid DoS\n        new Regex(\"^([a-z]*)*$\",\n                  RegexOptions.IgnoreCase,\n                  TimeSpan.FromSeconds(1)).Match(userInput);\n    }\n}\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
                  "markdown": "# Denial of Service from comparison of user input against expensive regex\nMatching user input against a regular expression which takes exponential time in the worst case can allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting input that takes a long time to execute.\n\nMost regular expression engines, including the C\\# standard library implementation, are designed to work with an extended regular expression syntax. Although this provides flexibility for the user, it can prevent the engine from constructing an efficient implementation of the matcher in all circumstances. In particular, the \"worst case time complexity\" (see the references) of certain regular expressions may be \"exponential\". This would allow a malicious user to provide some input which causes the regular expression to take a very long time to execute.\n\nTypically, a regular expression is vulnerable to this attack if it applies repetition to a sub-expression which itself is repeated, or contains overlapping options. For example, `(a+)+` is vulnerable to a string such as `aaaaaaaaaaaaaaaaaaaaaaaaaaab`. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to avoid the exponential worst case time. If this is not possible, then a timeout should be used to avoid a denial of service. For C\\# applications, a timeout can be provided to the `Regex` constructor. Alternatively, apply a global timeout by setting the `REGEX_DEFAULT_MATCH_TIMEOUT` application domain property, using the `AppDomain.SetData` method.\n\n\n## Example\nThe following example shows a HTTP request parameter that is matched against a regular expression which has exponential worst case performance. In the first case, it is matched without a timeout, which can lead to a denial of service. In the second case, a timeout is used to cancel the evaluation of the regular expression after 1 second.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Text.RegularExpressions;\n\npublic class ReDoSHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string userInput = ctx.Request.QueryString[\"userInput\"];\n\n        // BAD: User input is matched against a regex with exponential worst case behavior\n        new Regex(\"^([a-z]*)*$\").Match(userInput);\n\n        // GOOD: Regex is given a timeout to avoid DoS\n        new Regex(\"^([a-z]*)*$\",\n                  RegexOptions.IgnoreCase,\n                  TimeSpan.FromSeconds(1)).Match(userInput);\n    }\n}\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-1333",
                    "external/cwe/cwe-730",
                    "external/cwe/cwe-400"
                  ],
                  "description": "User input should not be matched against a regular expression that could require\n              exponential time on certain input.",
                  "id": "cs/redos",
                  "kind": "path-problem",
                  "name": "Denial of Service from comparison of user input against expensive regex",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/regex-injection",
                "name": "cs/regex-injection",
                "shortDescription": {
                  "text": "Regular expression injection"
                },
                "fullDescription": {
                  "text": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to provide a regex that could require exponential time on certain inputs."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nFor user input that is intended to be referenced as a string literal in a regular expression, use the `Regex.Escape` method to escape any special characters. If the regular expression is intended to be configurable by the user, then a timeout should be used to avoid Denial of Service attacks. For C\\# applications, a timeout can be provided to the `Regex` constructor. Alternatively, apply a global timeout by setting the `REGEX_DEFAULT_MATCH_TIMEOUT` application domain property, using the `AppDomain.SetData` method.\n\n\n## Example\nThe following example shows a HTTP request parameter that is used as a regular expression, and matched against another request parameter.\n\nIn the first case, the regular expression is used without a timeout, and the user-provided regex is not escaped. If a malicious user provides a regex that has exponential worst case performance, then this could lead to a Denial of Service.\n\nIn the second case, the user input is escaped using `Regex.Escape` before being included in the regular expression. This ensures that the user cannot insert characters which have a special meaning in regular expressions.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Text.RegularExpressions;\n\npublic class RegexInjectionHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string name = ctx.Request.QueryString[\"name\"];\n        string userInput = ctx.Request.QueryString[\"userInput\"];\n\n        // BAD: Unsanitized user input is used to construct a regular expression\n        new Regex(\"^\" + name + \"=.*$\").Match(userInput);\n\n        // GOOD: User input is sanitized before constructing the regex\n        string safeName = Regex.Escape(name);\n        new Regex(\"^\" + safeName + \"=.*$\").Match(userInput);\n    }\n}\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
                  "markdown": "# Regular expression injection\nConstructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.\n\n\n## Recommendation\nFor user input that is intended to be referenced as a string literal in a regular expression, use the `Regex.Escape` method to escape any special characters. If the regular expression is intended to be configurable by the user, then a timeout should be used to avoid Denial of Service attacks. For C\\# applications, a timeout can be provided to the `Regex` constructor. Alternatively, apply a global timeout by setting the `REGEX_DEFAULT_MATCH_TIMEOUT` application domain property, using the `AppDomain.SetData` method.\n\n\n## Example\nThe following example shows a HTTP request parameter that is used as a regular expression, and matched against another request parameter.\n\nIn the first case, the regular expression is used without a timeout, and the user-provided regex is not escaped. If a malicious user provides a regex that has exponential worst case performance, then this could lead to a Denial of Service.\n\nIn the second case, the user input is escaped using `Regex.Escape` before being included in the regular expression. This ensures that the user cannot insert characters which have a special meaning in regular expressions.\n\n\n```csharp\nusing System;\nusing System.Web;\nusing System.Text.RegularExpressions;\n\npublic class RegexInjectionHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string name = ctx.Request.QueryString[\"name\"];\n        string userInput = ctx.Request.QueryString[\"userInput\"];\n\n        // BAD: Unsanitized user input is used to construct a regular expression\n        new Regex(\"^\" + name + \"=.*$\").Match(userInput);\n\n        // GOOD: User input is sanitized before constructing the regex\n        string safeName = Regex.Escape(name);\n        new Regex(\"^\" + safeName + \"=.*$\").Match(userInput);\n    }\n}\n\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-730",
                    "external/cwe/cwe-400"
                  ],
                  "description": "User input should not be used in regular expressions without first being escaped,\n              otherwise a malicious user may be able to provide a regex that could require\n              exponential time on certain inputs.",
                  "id": "cs/regex-injection",
                  "kind": "path-problem",
                  "name": "Regular expression injection",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/hardcoded-connection-string-credentials",
                "name": "cs/hardcoded-connection-string-credentials",
                "shortDescription": {
                  "text": "Hard-coded connection string with credentials"
                },
                "fullDescription": {
                  "text": "Credentials are hard-coded in a connection string in the source code of the application."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Hard-coded connection string with credentials\nIncluding unencrypted hard-coded inbound or outbound authentication credentials within source code or configuration files is dangerous because the credentials may be easily discovered.\n\nSource or configuration files containing hard-coded credentials may be visible to an attacker. For example, the source code may be open source, or it may be leaked or accidentally revealed. For applications shipped as binaries, the credentials may be accessible within the compiled assemblies.\n\nFor inbound authentication, hard-coded credentials may allow unauthorized access to the system. This is particularly problematic if the credential is hard-coded in the source code, because it cannot be disabled easily. For outbound authentication, the hard-coded credentials may provide an attacker with privileged information or unauthorized access to some other system.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code, placing them in configuration files or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\nFor outbound authentication details, consider encrypting the credentials or the enclosing data stores or configuration files, and using permissions to restrict access.\n\nFor inbound authentication details, consider hashing passwords using standard library functions where possible. For example, Microsoft provide the class `Microsoft.AspNet.Identity.PasswordHasher`.\n\n\n## Example\nThe following examples shows different types of inbound and outbound authentication.\n\nIn the first case, we accept a password from a remote user, and compare it against a plaintext string literal. If an attacker acquires the source code, or the assemblies, they can observe the password, and can log in to the system. Furthermore, if such an intrusion was discovered, the application would need to be recompiled in order to change the password.\n\nIn the second case, the password is compared to a hashed and salted password stored in a configuration file, using the Microsoft provided `PasswordHasher.VerifyHashedPassword`. In this case, access to the source code or the assembly would not reveal the password to an attacker. Even access to the configuration file containing the password hash and salt would be of little value to an attacker, as it is usually extremely difficult to reverse engineer the password from the hash and salt.\n\nIn the final case, a password is changed to a new, hard-coded value. If an attacker has access to the source code, they will be able to observe the new password.\n\n\n```csharp\nusing Microsoft.AspNet.Identity;\nusing System;\nusing System.Web;\nusing System.Web.Security;\n\npublic class HardCodedCredentialHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string password = ctx.Request.QueryString[\"password\"];\n\n        // BAD: Inbound authentication made by comparison to string literal\n        if (password == \"myPa55word\")\n        {\n            ctx.Response.Redirect(\"login\");\n        }\n\n        string hashedPassword = loadPasswordFromSecretConfig();\n\n        // GOOD: Inbound authentication made by comparing to a hash password from a config\n        if (PasswordHasher.VerifyHashedPassword(hashedPassword, password))\n        {\n            ctx.Response.Redirect(VALID_REDIRECT);\n        }\n\n        // BAD: Set the password to a hardcoded string literal\n        MembershipUser user = loadMembershipUser();\n        user.ChangePassword(password, \"myNewPa55word\");\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n",
                  "markdown": "# Hard-coded connection string with credentials\nIncluding unencrypted hard-coded inbound or outbound authentication credentials within source code or configuration files is dangerous because the credentials may be easily discovered.\n\nSource or configuration files containing hard-coded credentials may be visible to an attacker. For example, the source code may be open source, or it may be leaked or accidentally revealed. For applications shipped as binaries, the credentials may be accessible within the compiled assemblies.\n\nFor inbound authentication, hard-coded credentials may allow unauthorized access to the system. This is particularly problematic if the credential is hard-coded in the source code, because it cannot be disabled easily. For outbound authentication, the hard-coded credentials may provide an attacker with privileged information or unauthorized access to some other system.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code, placing them in configuration files or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\nFor outbound authentication details, consider encrypting the credentials or the enclosing data stores or configuration files, and using permissions to restrict access.\n\nFor inbound authentication details, consider hashing passwords using standard library functions where possible. For example, Microsoft provide the class `Microsoft.AspNet.Identity.PasswordHasher`.\n\n\n## Example\nThe following examples shows different types of inbound and outbound authentication.\n\nIn the first case, we accept a password from a remote user, and compare it against a plaintext string literal. If an attacker acquires the source code, or the assemblies, they can observe the password, and can log in to the system. Furthermore, if such an intrusion was discovered, the application would need to be recompiled in order to change the password.\n\nIn the second case, the password is compared to a hashed and salted password stored in a configuration file, using the Microsoft provided `PasswordHasher.VerifyHashedPassword`. In this case, access to the source code or the assembly would not reveal the password to an attacker. Even access to the configuration file containing the password hash and salt would be of little value to an attacker, as it is usually extremely difficult to reverse engineer the password from the hash and salt.\n\nIn the final case, a password is changed to a new, hard-coded value. If an attacker has access to the source code, they will be able to observe the new password.\n\n\n```csharp\nusing Microsoft.AspNet.Identity;\nusing System;\nusing System.Web;\nusing System.Web.Security;\n\npublic class HardCodedCredentialHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string password = ctx.Request.QueryString[\"password\"];\n\n        // BAD: Inbound authentication made by comparison to string literal\n        if (password == \"myPa55word\")\n        {\n            ctx.Response.Redirect(\"login\");\n        }\n\n        string hashedPassword = loadPasswordFromSecretConfig();\n\n        // GOOD: Inbound authentication made by comparing to a hash password from a config\n        if (PasswordHasher.VerifyHashedPassword(hashedPassword, password))\n        {\n            ctx.Response.Redirect(VALID_REDIRECT);\n        }\n\n        // BAD: Set the password to a hardcoded string literal\n        MembershipUser user = loadMembershipUser();\n        user.ChangePassword(password, \"myNewPa55word\");\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-259",
                    "external/cwe/cwe-321",
                    "external/cwe/cwe-798"
                  ],
                  "description": "Credentials are hard-coded in a connection string in the source code of the application.",
                  "id": "cs/hardcoded-connection-string-credentials",
                  "kind": "path-problem",
                  "name": "Hard-coded connection string with credentials",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/hardcoded-credentials",
                "name": "cs/hardcoded-credentials",
                "shortDescription": {
                  "text": "Hard-coded credentials"
                },
                "fullDescription": {
                  "text": "Credentials are hard coded in the source code of the application."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# Hard-coded credentials\nIncluding unencrypted hard-coded inbound or outbound authentication credentials within source code or configuration files is dangerous because the credentials may be easily discovered.\n\nSource or configuration files containing hard-coded credentials may be visible to an attacker. For example, the source code may be open source, or it may be leaked or accidentally revealed. For applications shipped as binaries, the credentials may be accessible within the compiled assemblies.\n\nFor inbound authentication, hard-coded credentials may allow unauthorized access to the system. This is particularly problematic if the credential is hard-coded in the source code, because it cannot be disabled easily. For outbound authentication, the hard-coded credentials may provide an attacker with privileged information or unauthorized access to some other system.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code, placing them in configuration files or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\nFor outbound authentication details, consider encrypting the credentials or the enclosing data stores or configuration files, and using permissions to restrict access.\n\nFor inbound authentication details, consider hashing passwords using standard library functions where possible. For example, Microsoft provide the class `Microsoft.AspNet.Identity.PasswordHasher`.\n\n\n## Example\nThe following examples shows different types of inbound and outbound authentication.\n\nIn the first case, we accept a password from a remote user, and compare it against a plaintext string literal. If an attacker acquires the source code, or the assemblies, they can observe the password, and can log in to the system. Furthermore, if such an intrusion was discovered, the application would need to be recompiled in order to change the password.\n\nIn the second case, the password is compared to a hashed and salted password stored in a configuration file, using the Microsoft provided `PasswordHasher.VerifyHashedPassword`. In this case, access to the source code or the assembly would not reveal the password to an attacker. Even access to the configuration file containing the password hash and salt would be of little value to an attacker, as it is usually extremely difficult to reverse engineer the password from the hash and salt.\n\nIn the final case, a password is changed to a new, hard-coded value. If an attacker has access to the source code, they will be able to observe the new password.\n\n\n```csharp\nusing Microsoft.AspNet.Identity;\nusing System;\nusing System.Web;\nusing System.Web.Security;\n\npublic class HardCodedCredentialHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string password = ctx.Request.QueryString[\"password\"];\n\n        // BAD: Inbound authentication made by comparison to string literal\n        if (password == \"myPa55word\")\n        {\n            ctx.Response.Redirect(\"login\");\n        }\n\n        string hashedPassword = loadPasswordFromSecretConfig();\n\n        // GOOD: Inbound authentication made by comparing to a hash password from a config\n        if (PasswordHasher.VerifyHashedPassword(hashedPassword, password))\n        {\n            ctx.Response.Redirect(VALID_REDIRECT);\n        }\n\n        // BAD: Set the password to a hardcoded string literal\n        MembershipUser user = loadMembershipUser();\n        user.ChangePassword(password, \"myNewPa55word\");\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n",
                  "markdown": "# Hard-coded credentials\nIncluding unencrypted hard-coded inbound or outbound authentication credentials within source code or configuration files is dangerous because the credentials may be easily discovered.\n\nSource or configuration files containing hard-coded credentials may be visible to an attacker. For example, the source code may be open source, or it may be leaked or accidentally revealed. For applications shipped as binaries, the credentials may be accessible within the compiled assemblies.\n\nFor inbound authentication, hard-coded credentials may allow unauthorized access to the system. This is particularly problematic if the credential is hard-coded in the source code, because it cannot be disabled easily. For outbound authentication, the hard-coded credentials may provide an attacker with privileged information or unauthorized access to some other system.\n\n\n## Recommendation\nRemove hard-coded credentials, such as user names, passwords and certificates, from source code, placing them in configuration files or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.\n\nFor outbound authentication details, consider encrypting the credentials or the enclosing data stores or configuration files, and using permissions to restrict access.\n\nFor inbound authentication details, consider hashing passwords using standard library functions where possible. For example, Microsoft provide the class `Microsoft.AspNet.Identity.PasswordHasher`.\n\n\n## Example\nThe following examples shows different types of inbound and outbound authentication.\n\nIn the first case, we accept a password from a remote user, and compare it against a plaintext string literal. If an attacker acquires the source code, or the assemblies, they can observe the password, and can log in to the system. Furthermore, if such an intrusion was discovered, the application would need to be recompiled in order to change the password.\n\nIn the second case, the password is compared to a hashed and salted password stored in a configuration file, using the Microsoft provided `PasswordHasher.VerifyHashedPassword`. In this case, access to the source code or the assembly would not reveal the password to an attacker. Even access to the configuration file containing the password hash and salt would be of little value to an attacker, as it is usually extremely difficult to reverse engineer the password from the hash and salt.\n\nIn the final case, a password is changed to a new, hard-coded value. If an attacker has access to the source code, they will be able to observe the new password.\n\n\n```csharp\nusing Microsoft.AspNet.Identity;\nusing System;\nusing System.Web;\nusing System.Web.Security;\n\npublic class HardCodedCredentialHandler : IHttpHandler\n{\n\n    public void ProcessRequest(HttpContext ctx)\n    {\n        string password = ctx.Request.QueryString[\"password\"];\n\n        // BAD: Inbound authentication made by comparison to string literal\n        if (password == \"myPa55word\")\n        {\n            ctx.Response.Redirect(\"login\");\n        }\n\n        string hashedPassword = loadPasswordFromSecretConfig();\n\n        // GOOD: Inbound authentication made by comparing to a hash password from a config\n        if (PasswordHasher.VerifyHashedPassword(hashedPassword, password))\n        {\n            ctx.Response.Redirect(VALID_REDIRECT);\n        }\n\n        // BAD: Set the password to a hardcoded string literal\n        MembershipUser user = loadMembershipUser();\n        user.ChangePassword(password, \"myNewPa55word\");\n    }\n}\n\n```\n\n## References\n* OWASP: [XSS Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).\n* Microsoft Docs: [Preventing Open Redirection Attacks (C\\#)](https://docs.microsoft.com/en-us/aspnet/mvc/overview/security/preventing-open-redirection-attacks).\n* Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).\n* Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).\n* Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-259",
                    "external/cwe/cwe-321",
                    "external/cwe/cwe-798"
                  ],
                  "description": "Credentials are hard coded in the source code of the application.",
                  "id": "cs/hardcoded-credentials",
                  "kind": "path-problem",
                  "name": "Hard-coded credentials",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "9.8"
                }
              },
              {
                "id": "cs/user-controlled-bypass",
                "name": "cs/user-controlled-bypass",
                "shortDescription": {
                  "text": "User-controlled bypass of sensitive method"
                },
                "fullDescription": {
                  "text": "User-controlled bypassing of sensitive methods may allow attackers to avoid passing through authentication systems."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "error"
                },
                "help": {
                  "text": "# User-controlled bypass of sensitive method\nMany C\\# constructs enable code statements to be executed conditionally, for example, `if` statements and `for` statements. If the statements contain important authentication or login code, and user-controlled data determines whether or not the code is executed, an attacker may be able to bypass security systems.\n\n\n## Recommendation\nNever decide whether to authenticate a user based on data that may be controlled by that user. If necessary, ensure that the data is validated extensively when it is input before any authentication checks are performed.\n\nIt is still possible to have a system that \"remembers\" users, thus not requiring the user to login on every interaction. For example, personalization settings can be applied without authentication because this is not sensitive information. However, users should be allowed to take sensitive actions only when they have been fully authenticated.\n\n\n## Example\nThis example shows two ways of deciding whether to authenticate a user. The first way shows a decision that is based on the value of a cookie. Cookies can be easily controlled by the user, and so this allows a user to become authenticated without providing valid credentials. The second, more secure way shows a decision that is based on looking up the user in a security database.\n\n\n```csharp\npublic boolean doLogin(HttpCookie adminCookie, String user, String password)\n{\n\n    // BAD: login is executed only if the value of 'adminCookie' is 'false',\n    // but 'adminCookie' is controlled by the user\n    if (adminCookie.Value == \"false\")\n        return login(user, password);\n\n    return true;\n}\n\npublic boolean doLogin(HttpCookie adminCookie, String user, String password)\n{\n    // GOOD: use server-side information based on the credentials to decide\n    // whether user has privileges\n    bool isAdmin = queryDbForAdminStatus(user, password);\n    if (!isAdmin)\n        return login(user, password);\n\n    return true;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-247](https://cwe.mitre.org/data/definitions/247.html).\n* Common Weakness Enumeration: [CWE-350](https://cwe.mitre.org/data/definitions/350.html).\n",
                  "markdown": "# User-controlled bypass of sensitive method\nMany C\\# constructs enable code statements to be executed conditionally, for example, `if` statements and `for` statements. If the statements contain important authentication or login code, and user-controlled data determines whether or not the code is executed, an attacker may be able to bypass security systems.\n\n\n## Recommendation\nNever decide whether to authenticate a user based on data that may be controlled by that user. If necessary, ensure that the data is validated extensively when it is input before any authentication checks are performed.\n\nIt is still possible to have a system that \"remembers\" users, thus not requiring the user to login on every interaction. For example, personalization settings can be applied without authentication because this is not sensitive information. However, users should be allowed to take sensitive actions only when they have been fully authenticated.\n\n\n## Example\nThis example shows two ways of deciding whether to authenticate a user. The first way shows a decision that is based on the value of a cookie. Cookies can be easily controlled by the user, and so this allows a user to become authenticated without providing valid credentials. The second, more secure way shows a decision that is based on looking up the user in a security database.\n\n\n```csharp\npublic boolean doLogin(HttpCookie adminCookie, String user, String password)\n{\n\n    // BAD: login is executed only if the value of 'adminCookie' is 'false',\n    // but 'adminCookie' is controlled by the user\n    if (adminCookie.Value == \"false\")\n        return login(user, password);\n\n    return true;\n}\n\npublic boolean doLogin(HttpCookie adminCookie, String user, String password)\n{\n    // GOOD: use server-side information based on the credentials to decide\n    // whether user has privileges\n    bool isAdmin = queryDbForAdminStatus(user, password);\n    if (!isAdmin)\n        return login(user, password);\n\n    return true;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).\n* Common Weakness Enumeration: [CWE-247](https://cwe.mitre.org/data/definitions/247.html).\n* Common Weakness Enumeration: [CWE-350](https://cwe.mitre.org/data/definitions/350.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-807",
                    "external/cwe/cwe-247",
                    "external/cwe/cwe-350"
                  ],
                  "description": "User-controlled bypassing of sensitive methods may allow attackers to avoid\n              passing through authentication systems.",
                  "id": "cs/user-controlled-bypass",
                  "kind": "path-problem",
                  "name": "User-controlled bypass of sensitive method",
                  "precision": "high",
                  "problem.severity": "error",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/web/broad-cookie-domain",
                "name": "cs/web/broad-cookie-domain",
                "shortDescription": {
                  "text": "Cookie security: overly broad domain"
                },
                "fullDescription": {
                  "text": "Finds cookies with an overly broad domain."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Cookie security: overly broad domain\nThis rule finds cookies with an overly broad domain. Cookies with an overly broad domain, such as \".mybank.com\", can be accessed by all web applications deployed on this domain and its sub-domains. A cookie with sensitive data, but with too broad a domain, could hence be read and tampered with by a less secure and untrusted application.\n\n\n## Recommendation\nPrecisely define the domain of the web application for which this cookie is valid.\n\n\n## Example\nIn this example `cookie1` is accessible from online-bank.com. `cookie2` is accessible from ebanking.online-bank.com and any subdomains of ebanking.online-bank.com.\n\n\n```csharp\nclass CookieWithOverlyBroadDomain\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie1 = new HttpCookie(\"sessionID\");\n        cookie1.Domain = \"online-bank.com\";\n\n        HttpCookie cookie2 = new HttpCookie(\"sessionID\");\n        cookie2.Domain = \".ebanking.online-bank.com\";\n    }\n}\n\n```\nIn the following example `cookie` is only accessible from ebanking.online-bank.com which is much more secure.\n\n\n```csharp\nclass CookieWithOverlyBroadDomainFix\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie = new HttpCookie(\"sessionID\");\n        cookie.Domain = \"ebanking.online-bank.com\";\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpCookie.Domain Property](http://msdn.microsoft.com/en-us/library/system.web.httpcookie.domain.aspx).\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n",
                  "markdown": "# Cookie security: overly broad domain\nThis rule finds cookies with an overly broad domain. Cookies with an overly broad domain, such as \".mybank.com\", can be accessed by all web applications deployed on this domain and its sub-domains. A cookie with sensitive data, but with too broad a domain, could hence be read and tampered with by a less secure and untrusted application.\n\n\n## Recommendation\nPrecisely define the domain of the web application for which this cookie is valid.\n\n\n## Example\nIn this example `cookie1` is accessible from online-bank.com. `cookie2` is accessible from ebanking.online-bank.com and any subdomains of ebanking.online-bank.com.\n\n\n```csharp\nclass CookieWithOverlyBroadDomain\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie1 = new HttpCookie(\"sessionID\");\n        cookie1.Domain = \"online-bank.com\";\n\n        HttpCookie cookie2 = new HttpCookie(\"sessionID\");\n        cookie2.Domain = \".ebanking.online-bank.com\";\n    }\n}\n\n```\nIn the following example `cookie` is only accessible from ebanking.online-bank.com which is much more secure.\n\n\n```csharp\nclass CookieWithOverlyBroadDomainFix\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie = new HttpCookie(\"sessionID\");\n        cookie.Domain = \"ebanking.online-bank.com\";\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpCookie.Domain Property](http://msdn.microsoft.com/en-us/library/system.web.httpcookie.domain.aspx).\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-287"
                  ],
                  "description": "Finds cookies with an overly broad domain.",
                  "id": "cs/web/broad-cookie-domain",
                  "kind": "problem",
                  "name": "Cookie security: overly broad domain",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "9.3"
                }
              },
              {
                "id": "cs/web/broad-cookie-path",
                "name": "cs/web/broad-cookie-path",
                "shortDescription": {
                  "text": "Cookie security: overly broad path"
                },
                "fullDescription": {
                  "text": "Finds cookies with an overly broad path."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Cookie security: overly broad path\nThis rule finds cookies with an overly broad path. Cookies with an overly broad path, such as the root context path (\"/\"), can be accessed by all web applications on the same domain name. A cookie with sensitive data, but with too broad a path, could hence be read and tampered by a less secure and untrusted application.\n\n\n## Recommendation\nPrecisely define the path of the web application for which this cookie is valid.\n\n\n## Example\nIn this example the cookie will be accessible to all applications regardless of their path. Most likely some of these applications are less secure than others and do not even need to access the same cookies.\n\n\n```csharp\nclass CookieWithOverlyBroadPath\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie = new HttpCookie(\"sessionID\");\n        cookie.Path = \"/\";\n    }\n}\n\n```\nIn the following example the cookie is only accessible to the web application at the \"/ebanking\" path.\n\n\n```csharp\nclass CookieWithOverlyBroadPathFix\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie = new HttpCookie(\"sessionID\");\n        cookie.Path = \"/ebanking\";\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpCookie.Path Property](http://msdn.microsoft.com/en-us/library/system.web.httpcookie.path.aspx).\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n",
                  "markdown": "# Cookie security: overly broad path\nThis rule finds cookies with an overly broad path. Cookies with an overly broad path, such as the root context path (\"/\"), can be accessed by all web applications on the same domain name. A cookie with sensitive data, but with too broad a path, could hence be read and tampered by a less secure and untrusted application.\n\n\n## Recommendation\nPrecisely define the path of the web application for which this cookie is valid.\n\n\n## Example\nIn this example the cookie will be accessible to all applications regardless of their path. Most likely some of these applications are less secure than others and do not even need to access the same cookies.\n\n\n```csharp\nclass CookieWithOverlyBroadPath\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie = new HttpCookie(\"sessionID\");\n        cookie.Path = \"/\";\n    }\n}\n\n```\nIn the following example the cookie is only accessible to the web application at the \"/ebanking\" path.\n\n\n```csharp\nclass CookieWithOverlyBroadPathFix\n{\n    static public void AddCookie()\n    {\n        HttpCookie cookie = new HttpCookie(\"sessionID\");\n        cookie.Path = \"/ebanking\";\n    }\n}\n\n```\n\n## References\n* MSDN: [HttpCookie.Path Property](http://msdn.microsoft.com/en-us/library/system.web.httpcookie.path.aspx).\n* Common Weakness Enumeration: [CWE-287](https://cwe.mitre.org/data/definitions/287.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-287"
                  ],
                  "description": "Finds cookies with an overly broad path.",
                  "id": "cs/web/broad-cookie-path",
                  "kind": "problem",
                  "name": "Cookie security: overly broad path",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "9.3"
                }
              },
              {
                "id": "cs/ecb-encryption",
                "name": "cs/ecb-encryption",
                "shortDescription": {
                  "text": "Encryption using ECB"
                },
                "fullDescription": {
                  "text": "Highlights uses of the encryption mode 'CipherMode.ECB'. This mode should normally not be used because it is vulnerable to replay attacks."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Encryption using ECB\nECB should not be used as a mode for encryption. It has dangerous weaknesses. Data is encrypted the same way every time meaning the same plaintext input will always produce the same cyphertext. This makes encrypted messages vulnerable to replay attacks.\n\n\n## Recommendation\nUse a different CypherMode.\n\n\n## References\n* Wikipedia, Block cypher modes of operation, [Electronic codebook (ECB)](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
                  "markdown": "# Encryption using ECB\nECB should not be used as a mode for encryption. It has dangerous weaknesses. Data is encrypted the same way every time meaning the same plaintext input will always produce the same cyphertext. This makes encrypted messages vulnerable to replay attacks.\n\n\n## Recommendation\nUse a different CypherMode.\n\n\n## References\n* Wikipedia, Block cypher modes of operation, [Electronic codebook (ECB)](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-327"
                  ],
                  "description": "Highlights uses of the encryption mode 'CipherMode.ECB'. This mode should normally not be used because it is vulnerable to replay attacks.",
                  "id": "cs/ecb-encryption",
                  "kind": "problem",
                  "name": "Encryption using ECB",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/web/disabled-header-checking",
                "name": "cs/web/disabled-header-checking",
                "shortDescription": {
                  "text": "Header checking disabled"
                },
                "fullDescription": {
                  "text": "Finds places where header checking is disabled."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Header checking disabled\nThis rule finds places in the code where header checking is disabled. When header checking is enabled, which is the default, the `\\r` or `\\n` characters found in a response header are encoded to `%0d` and `%0a`. This defeats header-injection attacks by making the injected material part of the same header line. If you disable header checking, you open potential attack vectors against your client code.\n\n\n## Recommendation\nDo not disable header checking.\n\n\n## References\n* MSDN. [HttpRuntimeSection.EnableHeaderChecking Property](http://msdn.microsoft.com/en-us/library/system.web.configuration.httpruntimesection.enableheaderchecking.aspx).\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n",
                  "markdown": "# Header checking disabled\nThis rule finds places in the code where header checking is disabled. When header checking is enabled, which is the default, the `\\r` or `\\n` characters found in a response header are encoded to `%0d` and `%0a`. This defeats header-injection attacks by making the injected material part of the same header line. If you disable header checking, you open potential attack vectors against your client code.\n\n\n## Recommendation\nDo not disable header checking.\n\n\n## References\n* MSDN. [HttpRuntimeSection.EnableHeaderChecking Property](http://msdn.microsoft.com/en-us/library/system.web.configuration.httpruntimesection.enableheaderchecking.aspx).\n* Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-113"
                  ],
                  "description": "Finds places where header checking is disabled.",
                  "id": "cs/web/disabled-header-checking",
                  "kind": "problem",
                  "name": "Header checking disabled",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "6.1"
                }
              },
              {
                "id": "cs/inadequate-rsa-padding",
                "name": "cs/inadequate-rsa-padding",
                "shortDescription": {
                  "text": "Weak encryption: inadequate RSA padding"
                },
                "fullDescription": {
                  "text": "Finds uses of RSA encryption with inadequate padding."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Weak encryption: inadequate RSA padding\nThis query finds uses of RSA encryption without secure padding. Using PKCS\\#1 v1.5 padding can open up your application to several different attacks resulting in the exposure of the encryption key or the ability to determine plaintext from encrypted messages.\n\n\n## Recommendation\nUse the more secure PKCS\\#1 v2 (OAEP) padding.\n\n\n## References\n* Wikipedia. [RSA. Padding Schemes](http://en.wikipedia.org/wiki/RSA_(algorithm)#Padding_schemes).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-780](https://cwe.mitre.org/data/definitions/780.html).\n",
                  "markdown": "# Weak encryption: inadequate RSA padding\nThis query finds uses of RSA encryption without secure padding. Using PKCS\\#1 v1.5 padding can open up your application to several different attacks resulting in the exposure of the encryption key or the ability to determine plaintext from encrypted messages.\n\n\n## Recommendation\nUse the more secure PKCS\\#1 v2 (OAEP) padding.\n\n\n## References\n* Wikipedia. [RSA. Padding Schemes](http://en.wikipedia.org/wiki/RSA_(algorithm)#Padding_schemes).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-780](https://cwe.mitre.org/data/definitions/780.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-327",
                    "external/cwe/cwe-780"
                  ],
                  "description": "Finds uses of RSA encryption with inadequate padding.",
                  "id": "cs/inadequate-rsa-padding",
                  "kind": "problem",
                  "name": "Weak encryption: inadequate RSA padding",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/insecure-randomness",
                "name": "cs/insecure-randomness",
                "shortDescription": {
                  "text": "Insecure randomness"
                },
                "fullDescription": {
                  "text": "Using a cryptographically weak pseudo-random number generator to generate a security sensitive value may allow an attacker to predict what sensitive value will be generated."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security sensitive context. As a rule of thumb, a value should be considered \"security sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor C\\#, `RNGCryptoServiceProvider` provides a cryptographically secure pseudo-random number generator. `Random` is not cryptographically secure, and should be avoided in security contexts. For contexts which are not security sensitive, `Random` may be preferable as it has a more convenient interface, and is likely to be faster.\n\nFor the specific use-case of generating passwords, consider `System.Web.Security.Membership.GeneratePassword`, which provides a cryptographically secure method of generating random passwords.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\nIn the final example, the password is generated using the `Membership.GeneratePassword` library method, which uses a cryptographically secure random number generator to generate a random series of characters. This method should be preferred when generating passwords, if possible, as it avoids potential pitfalls when converting the output of a random number generator (usually an int or a byte) to a series of permitted characters.\n\n\n```csharp\nusing System.Security.Cryptography;\nusing System.Web.Security;\n\nstring GeneratePassword()\n{\n    // BAD: Password is generated using a cryptographically insecure RNG\n    Random gen = new Random();\n    string password = \"mypassword\" + gen.Next();\n\n    // GOOD: Password is generated using a cryptographically secure RNG\n    using (RNGCryptoServiceProvider crypto = new RNGCryptoServiceProvider())\n    {\n        byte[] randomBytes = new byte[sizeof(int)];\n        crypto.GetBytes(randomBytes);\n        password = \"mypassword\" + BitConverter.ToInt32(randomBytes);\n    }\n\n    // BAD: Membership.GeneratePassword generates a password with a bias\n    password = Membership.GeneratePassword(12, 3);\n\n    return password;\n}\n\n```\n\n## References\n* Wikipedia. [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* MSDN. [RandomNumberGenerator](http://msdn.microsoft.com/en-us/library/system.security.cryptography.randomnumbergenerator.aspx).\n* MSDN. [Membership.GeneratePassword](https://msdn.microsoft.com/en-us/library/system.web.security.membership.generatepassword(v=vs.110).aspx).\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
                  "markdown": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security sensitive context. As a rule of thumb, a value should be considered \"security sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor C\\#, `RNGCryptoServiceProvider` provides a cryptographically secure pseudo-random number generator. `Random` is not cryptographically secure, and should be avoided in security contexts. For contexts which are not security sensitive, `Random` may be preferable as it has a more convenient interface, and is likely to be faster.\n\nFor the specific use-case of generating passwords, consider `System.Web.Security.Membership.GeneratePassword`, which provides a cryptographically secure method of generating random passwords.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\nIn the final example, the password is generated using the `Membership.GeneratePassword` library method, which uses a cryptographically secure random number generator to generate a random series of characters. This method should be preferred when generating passwords, if possible, as it avoids potential pitfalls when converting the output of a random number generator (usually an int or a byte) to a series of permitted characters.\n\n\n```csharp\nusing System.Security.Cryptography;\nusing System.Web.Security;\n\nstring GeneratePassword()\n{\n    // BAD: Password is generated using a cryptographically insecure RNG\n    Random gen = new Random();\n    string password = \"mypassword\" + gen.Next();\n\n    // GOOD: Password is generated using a cryptographically secure RNG\n    using (RNGCryptoServiceProvider crypto = new RNGCryptoServiceProvider())\n    {\n        byte[] randomBytes = new byte[sizeof(int)];\n        crypto.GetBytes(randomBytes);\n        password = \"mypassword\" + BitConverter.ToInt32(randomBytes);\n    }\n\n    // BAD: Membership.GeneratePassword generates a password with a bias\n    password = Membership.GeneratePassword(12, 3);\n\n    return password;\n}\n\n```\n\n## References\n* Wikipedia. [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* MSDN. [RandomNumberGenerator](http://msdn.microsoft.com/en-us/library/system.security.cryptography.randomnumbergenerator.aspx).\n* MSDN. [Membership.GeneratePassword](https://msdn.microsoft.com/en-us/library/system.web.security.membership.generatepassword(v=vs.110).aspx).\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-338"
                  ],
                  "description": "Using a cryptographically weak pseudo-random number generator to generate a\n              security sensitive value may allow an attacker to predict what sensitive value will\n              be generated.",
                  "id": "cs/insecure-randomness",
                  "kind": "path-problem",
                  "name": "Insecure randomness",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.8"
                }
              },
              {
                "id": "cs/insufficient-key-size",
                "name": "cs/insufficient-key-size",
                "shortDescription": {
                  "text": "Weak encryption: Insufficient key size"
                },
                "fullDescription": {
                  "text": "Finds uses of encryption algorithms with too small a key size"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Weak encryption: Insufficient key size\nThis rule finds uses of encryption algorithms with too small a key size. Encryption algorithms are vulnerable to brute force attack when too small a key size is used.\n\n\n## Recommendation\nThe key should be at least 2048-bit long when using RSA encryption, and 128-bit long when using symmetric encryption.\n\n\n## References\n* Wikipedia. [Key size](http://en.wikipedia.org/wiki/Key_size).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
                  "markdown": "# Weak encryption: Insufficient key size\nThis rule finds uses of encryption algorithms with too small a key size. Encryption algorithms are vulnerable to brute force attack when too small a key size is used.\n\n\n## Recommendation\nThe key should be at least 2048-bit long when using RSA encryption, and 128-bit long when using symmetric encryption.\n\n\n## References\n* Wikipedia. [Key size](http://en.wikipedia.org/wiki/Key_size).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-326"
                  ],
                  "description": "Finds uses of encryption algorithms with too small a key size",
                  "id": "cs/insufficient-key-size",
                  "kind": "problem",
                  "name": "Weak encryption: Insufficient key size",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/web/persistent-cookie",
                "name": "cs/web/persistent-cookie",
                "shortDescription": {
                  "text": "Cookie security: persistent cookie"
                },
                "fullDescription": {
                  "text": "Persistent cookies are vulnerable to attacks."
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Cookie security: persistent cookie\nThis rule finds cookies that are made to expire in more than 5 minutes from now. Cookies are usually non-persistent, in which case they reside in the browser's memory only. However, by setting an expiration date in the future, cookies can be made persistent and are then written to disk to survive the browser restarts. If a persistent cookie is set to expire in a fairly distant future, it is easier for an attacker to steal its data.\n\n\n## Recommendation\nDo not put sensitive information in persistent cookies.\n\n\n## References\n* Common Weakness Enumeration: [CWE-539](https://cwe.mitre.org/data/definitions/539.html).\n",
                  "markdown": "# Cookie security: persistent cookie\nThis rule finds cookies that are made to expire in more than 5 minutes from now. Cookies are usually non-persistent, in which case they reside in the browser's memory only. However, by setting an expiration date in the future, cookies can be made persistent and are then written to disk to survive the browser restarts. If a persistent cookie is set to expire in a fairly distant future, it is easier for an attacker to steal its data.\n\n\n## Recommendation\nDo not put sensitive information in persistent cookies.\n\n\n## References\n* Common Weakness Enumeration: [CWE-539](https://cwe.mitre.org/data/definitions/539.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-539"
                  ],
                  "description": "Persistent cookies are vulnerable to attacks.",
                  "id": "cs/web/persistent-cookie",
                  "kind": "problem",
                  "name": "Cookie security: persistent cookie",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "8.2"
                }
              },
              {
                "id": "cs/weak-encryption",
                "name": "cs/weak-encryption",
                "shortDescription": {
                  "text": "Weak encryption"
                },
                "fullDescription": {
                  "text": "Finds uses of encryption algorithms that are weak and obsolete"
                },
                "defaultConfiguration": {
                  "enabled": true,
                  "level": "warning"
                },
                "help": {
                  "text": "# Weak encryption\nWeak encryption algorithms provide very little security. For example DES encryption uses keys of 56 bits only, and no longer provides sufficient protection for sensitive data. TripleDES should also be deprecated for very sensitive data: Although it improves on DES by using 168-bit long keys, it provides in fact at most 112 bits of security.\n\n\n## Recommendation\nYou should switch to a more secure encryption algorithm, such as AES (Advanced Encryption Standard) and use a key length which is reasonable for the application for which it is being used.\n\n\n## Example\nThis example uses DES, which is limited to a 56-bit key. The key provided is actually 64 bits but the last bit of each byte is turned into a parity bit. For example the bytes 01010101 and 01010100 can be used in place of each other when encrypting and decrypting.\n\n\n```csharp\nclass WeakEncryption\n{\n    public static byte[] encryptString()\n    {\n        SymmetricAlgorithm serviceProvider = new DESCryptoServiceProvider();\n        byte[] key = { 16, 22, 240, 11, 18, 150, 192, 21 };\n        serviceProvider.Key = key;\n        ICryptoTransform encryptor = serviceProvider.CreateEncryptor();\n\n        String message = \"Hello World\";\n        byte[] messageB = System.Text.Encoding.ASCII.GetBytes(message);\n        return encryptor.TransformFinalBlock(messageB, 0, messageB.Length);\n    }\n}\n\n```\n\n## References\n* Wikipedia: [Key Size](http://en.wikipedia.org/wiki/Key_size)\n* Wikipedia: [DES](http://en.wikipedia.org/wiki/Data_Encryption_Standard)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
                  "markdown": "# Weak encryption\nWeak encryption algorithms provide very little security. For example DES encryption uses keys of 56 bits only, and no longer provides sufficient protection for sensitive data. TripleDES should also be deprecated for very sensitive data: Although it improves on DES by using 168-bit long keys, it provides in fact at most 112 bits of security.\n\n\n## Recommendation\nYou should switch to a more secure encryption algorithm, such as AES (Advanced Encryption Standard) and use a key length which is reasonable for the application for which it is being used.\n\n\n## Example\nThis example uses DES, which is limited to a 56-bit key. The key provided is actually 64 bits but the last bit of each byte is turned into a parity bit. For example the bytes 01010101 and 01010100 can be used in place of each other when encrypting and decrypting.\n\n\n```csharp\nclass WeakEncryption\n{\n    public static byte[] encryptString()\n    {\n        SymmetricAlgorithm serviceProvider = new DESCryptoServiceProvider();\n        byte[] key = { 16, 22, 240, 11, 18, 150, 192, 21 };\n        serviceProvider.Key = key;\n        ICryptoTransform encryptor = serviceProvider.CreateEncryptor();\n\n        String message = \"Hello World\";\n        byte[] messageB = System.Text.Encoding.ASCII.GetBytes(message);\n        return encryptor.TransformFinalBlock(messageB, 0, messageB.Length);\n    }\n}\n\n```\n\n## References\n* Wikipedia: [Key Size](http://en.wikipedia.org/wiki/Key_size)\n* Wikipedia: [DES](http://en.wikipedia.org/wiki/Data_Encryption_Standard)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
                },
                "properties": {
                  "tags": [
                    "security",
                    "external/cwe/cwe-327"
                  ],
                  "description": "Finds uses of encryption algorithms that are weak and obsolete",
                  "id": "cs/weak-encryption",
                  "kind": "problem",
                  "name": "Weak encryption",
                  "precision": "high",
                  "problem.severity": "warning",
                  "security-severity": "7.5"
                }
              },
              {
                "id": "cs/summary/lines-of-code",
                "name": "cs/summary/lines-of-code",
                "shortDescription": {
                  "text": "Total lines of code in the database"
                },
                "fullDescription": {
                  "text": "The total number of lines of code across all files. This is a useful metric of the size of a database. For all files that were seen during the build, this query counts the lines of code, excluding whitespace or comments."
                },
                "defaultConfiguration": {
                  "enabled": true
                },
                "properties": {
                  "tags": [
                    "summary",
                    "lines-of-code"
                  ],
                  "description": "The total number of lines of code across all files. This is a useful metric of the size of a database. For all files that were seen during the build, this query counts the lines of code, excluding whitespace or comments.",
                  "id": "cs/summary/lines-of-code",
                  "kind": "metric",
                  "name": "Total lines of code in the database"
                }
              }
            ],
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/csharp-queries/0.0.9/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/csharp-queries/0.0.9/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "legacy-upgrades",
            "semanticVersion": "0.0.0",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/legacy-upgrades/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/legacy-upgrades/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/javascript-queries",
            "semanticVersion": "0.0.10+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/javascript-queries/0.0.10/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/javascript-queries/0.0.10/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/python-queries",
            "semanticVersion": "0.0.9+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/python-queries/0.0.9/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/python-queries/0.0.9/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/go-queries",
            "semanticVersion": "0.0.8+6403a23af36f3dd0a16329c9343319249673e8ac",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/go-queries/0.0.8/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/go-queries/0.0.8/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/cpp-all",
            "semanticVersion": "0.0.9+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/cpp-all/0.0.9/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/cpp-all/0.0.9/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/ruby-all",
            "semanticVersion": "0.0.9+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/ruby-all/0.0.9/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/ruby-all/0.0.9/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/java-queries",
            "semanticVersion": "0.0.9+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/java-queries/0.0.9/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/java-queries/0.0.9/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/ruby-queries",
            "semanticVersion": "0.0.9+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/ruby-queries/0.0.9/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/ruby-queries/0.0.9/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/javascript-examples",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/javascript-examples/0.0.0/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/javascript-examples/0.0.0/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/cpp-examples",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/cpp-examples/0.0.0/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/cpp-examples/0.0.0/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          },
          {
            "name": "codeql/csharp-all",
            "semanticVersion": "0.0.9+74ed89409cd1d3f836c646ea82bb70a53fcca306",
            "locations": [
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/csharp-all/0.0.9/",
                "description": {
                  "text": "The QL pack root directory."
                }
              },
              {
                "uri": "file:///opt/hostedtoolcache/CodeQL/0.0.0-20220214/x64/codeql/qlpacks/codeql/csharp-all/0.0.9/qlpack.yml",
                "description": {
                  "text": "The QL pack definition file."
                }
              }
            ]
          }
        ]
      },
      "invocations": [
        {
          "toolExecutionNotifications": [
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Configuration/ConfigurationSource.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 1
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Configuration/IdentityServerConfiguration.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 2
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/DataContexts/TsaIdentityDbContext.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 3
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Migrations/ConfigurationDb/ConfigurationDbContextModelSnapshot.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 4
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Migrations/ConfigurationDb/IdentityServerConfigurationDbMigration.Designer.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 5
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Migrations/ConfigurationDb/IdentityServerConfigurationDbMigration.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 6
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Migrations/InitialIdentityServerPersistedGrantDbMigration.Designer.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 7
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Migrations/InitialIdentityServerPersistedGrantDbMigration.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 8
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Migrations/PersistedGrantDbContextModelSnapshot.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 9
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Migrations/TsaIdentityDb/TsaIdentityDbContextModelSnapshot.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 10
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Migrations/TsaIdentityDb/TsaIdentityServerMigration.Designer.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 11
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Migrations/TsaIdentityDb/TsaIdentityServerMigration.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 12
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Program.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 13
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 0
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountOptions.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 14
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/LoggedOutViewModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 15
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/LoginInputModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 16
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/LoginViewModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 17
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/LogoutInputModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 18
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/LogoutViewModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 19
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/RedirectViewModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 20
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Consent/ConsentController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 21
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Consent/ConsentInputModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 22
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Consent/ConsentOptions.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 23
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Consent/ConsentViewModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 24
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Consent/ProcessConsentResult.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 25
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Consent/ScopeViewModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 26
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Device/DeviceAuthorizationInputModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 27
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Device/DeviceController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 28
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Device/DeviceAuthorizationViewModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 29
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Diagnostics/DiagnosticsController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 30
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Diagnostics/DiagnosticsViewModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 31
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Extensions.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 32
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Grants/GrantsController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 33
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Grants/GrantsViewModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 34
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Home/ErrorViewModel.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 35
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/Home/HomeController.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 36
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Quickstart/SecurityHeadersAttribute.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 37
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/Startup.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 38
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 39
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Account/AccessDenied.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 40
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Account/Login.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 41
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Account/LoggedOut.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 42
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Account/Logout.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 43
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Consent/Index.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 44
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Device/Success.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 45
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Device/UserCodeCapture.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 46
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Device/UserCodeConfirmation.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 47
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Diagnostics/Index.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 48
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Grants/Index.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 49
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Home/Index.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 50
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Shared/Error.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 51
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Shared/Redirect.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 52
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Shared/_Layout.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 53
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Shared/_Nav.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 54
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Shared/_ScopeListItem.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 55
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Shared/_ValidationSummary.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 56
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/_ViewImports.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 57
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Tsa.IdentityServer.Web.AssemblyInfo.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 58
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Tsa.IdentityServer.Web.RazorAssemblyInfo.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 59
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Tsa.IdentityServer.Web.RazorTargetAssemblyInfo.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 60
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            },
            {
              "locations": [
                {
                  "physicalLocation": {
                    "artifactLocation": {
                      "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/_ViewStart.cshtml.g.cs",
                      "uriBaseId": "%SRCROOT%",
                      "index": 61
                    }
                  }
                }
              ],
              "message": {
                "text": ""
              },
              "level": "none",
              "descriptor": {
                "id": "cs/diagnostics/successfully-extracted-files",
                "index": 1,
                "toolComponent": {
                  "index": 11
                }
              },
              "properties": {
                "formattedMessage": {
                  "text": ""
                },
                "relatedLocations": []
              }
            }
          ],
          "executionSuccessful": true
        }
      ],
      "artifacts": [
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 0
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Configuration/ConfigurationSource.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 1
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Configuration/IdentityServerConfiguration.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 2
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/DataContexts/TsaIdentityDbContext.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 3
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Migrations/ConfigurationDb/ConfigurationDbContextModelSnapshot.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 4
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Migrations/ConfigurationDb/IdentityServerConfigurationDbMigration.Designer.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 5
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Migrations/ConfigurationDb/IdentityServerConfigurationDbMigration.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 6
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Migrations/InitialIdentityServerPersistedGrantDbMigration.Designer.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 7
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Migrations/InitialIdentityServerPersistedGrantDbMigration.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 8
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Migrations/PersistedGrantDbContextModelSnapshot.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 9
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Migrations/TsaIdentityDb/TsaIdentityDbContextModelSnapshot.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 10
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Migrations/TsaIdentityDb/TsaIdentityServerMigration.Designer.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 11
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Migrations/TsaIdentityDb/TsaIdentityServerMigration.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 12
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Program.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 13
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountOptions.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 14
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/LoggedOutViewModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 15
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/LoginInputModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 16
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/LoginViewModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 17
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/LogoutInputModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 18
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/LogoutViewModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 19
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/RedirectViewModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 20
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Consent/ConsentController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 21
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Consent/ConsentInputModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 22
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Consent/ConsentOptions.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 23
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Consent/ConsentViewModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 24
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Consent/ProcessConsentResult.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 25
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Consent/ScopeViewModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 26
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Device/DeviceAuthorizationInputModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 27
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Device/DeviceController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 28
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Device/DeviceAuthorizationViewModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 29
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Diagnostics/DiagnosticsController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 30
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Diagnostics/DiagnosticsViewModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 31
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Extensions.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 32
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Grants/GrantsController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 33
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Grants/GrantsViewModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 34
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Home/ErrorViewModel.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 35
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Home/HomeController.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 36
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Quickstart/SecurityHeadersAttribute.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 37
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/Startup.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 38
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 39
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Account/AccessDenied.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 40
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Account/Login.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 41
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Account/LoggedOut.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 42
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Account/Logout.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 43
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Consent/Index.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 44
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Device/Success.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 45
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Device/UserCodeCapture.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 46
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Device/UserCodeConfirmation.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 47
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Diagnostics/Index.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 48
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Grants/Index.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 49
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Home/Index.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 50
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Shared/Error.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 51
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Shared/Redirect.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 52
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Shared/_Layout.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 53
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Shared/_Nav.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 54
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Shared/_ScopeListItem.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 55
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/Shared/_ValidationSummary.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 56
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/_ViewImports.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 57
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Tsa.IdentityServer.Web.AssemblyInfo.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 58
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Tsa.IdentityServer.Web.RazorAssemblyInfo.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 59
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Tsa.IdentityServer.Web.RazorTargetAssemblyInfo.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 60
          }
        },
        {
          "location": {
            "uri": "src/Tsa.IdentityServer.Web/obj/Debug/net5.0/Razor/Views/_ViewStart.cshtml.g.cs",
            "uriBaseId": "%SRCROOT%",
            "index": 61
          }
        }
      ],
      "results": [
        {
          "ruleId": "cs/user-controlled-bypass",
          "rule": {
            "id": "cs/user-controlled-bypass",
            "index": 33,
            "toolComponent": {
              "index": 11
            }
          },
          "message": {
            "text": "Sensitive method may not be executed depending on [this condition](1), which flows from [user input](2)."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 0
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 27,
                  "endColumn": 104
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "61d033b123f5872e:1",
            "primaryLocationStartColumnFingerprint": "6"
          },
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 0
                          },
                          "region": {
                            "startLine": 71,
                            "startColumn": 78,
                            "endColumn": 84
                          }
                        },
                        "message": {
                          "text": "button : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 0
                          },
                          "region": {
                            "startLine": 77,
                            "startColumn": 17,
                            "endColumn": 34
                          }
                        },
                        "message": {
                          "text": "... != ..."
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 0
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 17,
                  "endColumn": 34
                }
              },
              "message": {
                "text": "this condition"
              }
            },
            {
              "id": 2,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 0
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 78,
                  "endColumn": 84
                }
              },
              "message": {
                "text": "user input"
              }
            }
          ]
        },
        {
          "ruleId": "cs/user-controlled-bypass",
          "rule": {
            "id": "cs/user-controlled-bypass",
            "index": 33,
            "toolComponent": {
              "index": 11
            }
          },
          "message": {
            "text": "Sensitive method may not be executed depending on [this condition](1), which flows from [user input](2)."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 0
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 28,
                  "endColumn": 59
                }
              }
            }
          ],
          "partialFingerprints": {
            "primaryLocationLineHash": "c27c1d8b0143300a:1",
            "primaryLocationStartColumnFingerprint": "15"
          },
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 0
                          },
                          "region": {
                            "startLine": 71,
                            "startColumn": 78,
                            "endColumn": 84
                          }
                        },
                        "message": {
                          "text": "button : String"
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountController.cs",
                            "uriBaseId": "%SRCROOT%",
                            "index": 0
                          },
                          "region": {
                            "startLine": 77,
                            "startColumn": 17,
                            "endColumn": 34
                          }
                        },
                        "message": {
                          "text": "... != ..."
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "relatedLocations": [
            {
              "id": 1,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 0
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 17,
                  "endColumn": 34
                }
              },
              "message": {
                "text": "this condition"
              }
            },
            {
              "id": 2,
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Tsa.IdentityServer.Web/Quickstart/Account/AccountController.cs",
                  "uriBaseId": "%SRCROOT%",
                  "index": 0
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 78,
                  "endColumn": 84
                }
              },
              "message": {
                "text": "user input"
              }
            }
          ]
        }
      ],
      "columnKind": "utf16CodeUnits",
      "properties": {
        "metricResults": [
          {
            "rule": {
              "id": "cs/summary/lines-of-code",
              "index": 43,
              "toolComponent": {
                "index": 11
              }
            },
            "ruleId": "cs/summary/lines-of-code",
            "value": 7525,
            "baseline": 4330
          }
        ],
        "semmle.formatSpecifier": "sarif-latest"
      }
    }
  ]
}